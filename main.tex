%&../.preamble

\externalize{../.preamble}

\usepackage{pifont}
% \usepackage{amssymb}        % gives \bigstar
\title{Pelstra di algoritmi}
\author{Marini Mattia}
\date{20 ottobre 2025}

\begin{document}
\maketitle
\license{Palestra di algoritmi}
\tableofcontents
\newpage

\section{Introduzione}
Qui di seguito sono raccolte nozioni di base per affrontare ogni probrema relativo alle \textit{OII}

\subsection{Basi cpp}
In ogni problema è necessario effettuare input/output su file\footnote{In realtà a volte è sufficiente implementare il body di una funzione oppure la parte relativa all'output viene fornita}. Ci sono diversi modi per eseguire ciò.
\subsubsection{Input metodo 1 (consigliato)}
Vedi file \href{run:./files/teoria/input1/}{input1.cpp}
\vskip3mm
L'idea è di creare un oggeto \verb|ifstream| e \verb|ofstream| che poi potremmo utilizzare in maniera totalmente analoga a, rispettivamente, \verb|cin| e \verb|cout|
\begin{lstlisting}[language = cpp, frame = none]
std::ifstream in("input.txt");
in >> a >> b;

std::ifstream out("output.txt");
out << a << b
\end{lstlisting}
Esiste un trucco per velocizzare notevolmente la velocità di input/output utilizzando questo metodo. In particolare, è sufficiente appendere le seguenti righe prima di scrivere o leggere su files:
\begin{lstlisting}[language = cpp, frame = none]
ios_base::sync_with_stdio(false); 
cin.tie(NULL);
\end{lstlisting}
Tuttavia se il problema sfora i limiti di tempo, con ogni probabilità è la soluzione a non essere corretta, non le operazioni di input/output. Queste righe possono essere utili per scalare la classifica sui siti di allenamento, non per altro

\subsubsection{Input metodo 2}
Vedi file \href{run:./files/teoria/input/}{input2.cpp}
\vskip3mm
Questo metodo è più "vecchio" e meno consigliato. L'idea è di utilizzare le funzioni \verb|freopen| per reindirizzare lo standard input/output su file:
\begin{lstlisting}[language = cpp, frame = none]
FILE *in = fopen("input.txt", "r");
fscanf(in, "%d %d", &a, &b);

FILE *out = fopen("output.txt", "w");
fprintf(out, "%d %d\n", a, b);
\end{lstlisting}
dove le funzioni \verb|fprintf| e \verb|fscanf| prendono come argomenti:
\begin{itemize}
	\item Il puntatore ad un file \verb|FILE *|
	\item Una stringa \verb|format|, contenente una serie di specificatori, preceduti da "{\ttfamily \%}"
	      \begin{itemize}
		      \item \verb|d|: decimal, numero intero
		      \item \verb|f|: float
		      \item \verb|s|: stringa c-style, in particolare \verb|char *|
	      \end{itemize}
	\item Una serie variabili che corrispondono a quanto indicato in \verb|format|. Nel caso di \verb|scanf| è richiesto l'indirizzo di memoria di queset
\end{itemize}
\subsubsection{Ultra fast io}
Ci sono infine alcuni metodi per velocizzare l'input al massimo, utili per sprepere la perfomance al massimo, per arrivare nei primi in classifica. In particolare, questi metodi si basano sull'uso delle funzioni \verb|getchat_unlocked()| e \verb|putchar_unlocked()|
\begin{lstlisting}[language = cpp, frame = none]
inline static int scanInt(FILE *file = stdin) {
  int n = 0;
  int neg = 1;
  char c = getc_unlocked(file);
  if (c == '-')
    neg = -1;
  while (c < '0' || c > '9') {
    c = getc_unlocked(file);
    if (c == '-')
      neg = -1;
  }
  while (c >= '0' && c <= '9') {
    n = (n << 3) + (n << 1) + c - '0';
    c = getc_unlocked(file);
  }
  return n * neg;
}

inline static void writeInt(int v, FILE *file = stdout) {
  static char buf[14];
  int p = 0;
  if (v == 0) {
    putc_unlocked('0', file);
    return;
  }
  if (v < 0) {
    putc_unlocked('-', file);
    v = -v;
  }
  while (v) {
    buf[p++] = v % 10;
    v /= 10;
  }
  while (p--) {
    putc_unlocked(buf[p] + '0', file);
  }
}

inline static int getString(char *buf, FILE *file = stdin) {
  std::string s;
  int c = getc_unlocked(file);

  // Skip leading whitespace
  while (c != EOF && (c == ' ' || c == '\n' || c == '\t' || c == '\r'))
    c = getc_unlocked(file);

  // Read until next whitespace or EOF
  int index = 0;
  while (c != EOF && c != ' ' && c != '\n' && c != '\t' && c != '\r') {
    buf[index++] = static_cast<char>(c);
    c = getc_unlocked(file);
  }

  return index;
}

inline static void putString(const std::string &s, FILE *file = stdout) {
  for (size_t i = 0; i < s.size(); i++)
    putc_unlocked(s[i], file);
}
\end{lstlisting}
Nota che le funzioni \verb|putc_unlocked| e \verb|getc_unlocked| sono disponibili solo in sistemi operativi unix(MacOs e Linux). Si possono usare in tranquillità dato che i server che testano il nostro codice sono tutti linux, ma il codice potrebbe non compilare in locale

\subsection{Complessità}
Il punto focale delle olimpiadi di informatica è non solo quello di scrivere algoritmi funzionanti, bensì efficienti. Per questa ragione è importante fornire critesi secondo i quali valutare la velocità d'esecuzione degli algoritmi
\vskip3mm
La logica di base sta nel relazionare il \textit{numero di iterazioni} che un algoritmo deve eseguire alla \textit{dimensione dell'input}.

\subsubsection{Esempio 1}
Supponiamo di avere un algoritmo per trovare il massimo in un vettore di $ n $ elementi. L'algoritmo fa quanto segue:
\begin{itemize}
	\item Inizializza una variabile \verb|max| al primo elemento del vettore
	\item Per ogni elemento del vettore controlla se è maggiore di \verb|max|. In caso affermativo aggiorna \verb|max| all'elemento corrente
	\item Ritorna \verb|max|
\end{itemize}
\begin{algoritmo*}{Massimo vettore}
	\begin{algorithm}[H]
		\SetKwFunction{Max}{\Int max}
		\Fn{ \Max{$\Int\ v[]$}}{
			$max \gets v\left[0\right]$\;
			\For{$i = 0$ \KwTo $v.size - 1$}{
				\If{$v\left[i\right] > max$}{
					$max \gets v\left[i\right]$\;
				}
			}
			\Return{$max$}\;
		}
	\end{algorithm}
\end{algoritmo*}
In questo caso notiamo come siano necessarie $ n $ \textit{iterazioni} perchè l'algoritmo termini (dove $ n $ è la dimensione del vettore $ v $). Abbiamo quindi rapportato la dimensione dell'input alla complessità temporale dell'algoritmo
\vskip3mm
In questo caso, si dice che la complessità dell'algoritmo è $ \Theta \left(n\right) $

\subsubsection{Esempio 2}
Supponiamo di avere un algorimo che debba eseguire una moltiplicazione applicando la proprietà distributiva:
\[
	\left(a + b + c\right)\cdot \left(d + e + f\right)
\]
secondo la proprietà distributiva questo diventa:
\[
	\underbracket[0.1ex]{\left(ad + ae + af\right)}_{A}+ \underbracket[0.1ex]{\left(bd + be + bf\right)}_{B} + \underbracket[0.1ex]{\left(cd + ce + cf\right)}_{C}
\]
ritornare un vettore che contenga i coefficienti $ \left(A,B,C\right) $

\begin{algoritmo*}{Moltiplicazione distributiva}
	\begin{algorithm}[H]
		\SetKwFunction{Mul}{\Int mul}
		\Fn{ \Mul{$\Int\ v_1[]$, $\Int\ v_2[]$}}{
		$\Int\; rv$ = $\Int[0 \ldots v1.size]$\;
		\For{$i = 0$ \KwTo $v_1.size - 1$}{
			$ rv\left[i\right] = 0$\;
			\For{$j = 0$ \KwTo $v_2.size - 1$}{
				$ rv += v_1\left[i\right] \cdot  v_2\left[j\right] $\;
			}
		}
		\Return{$rv$}\;
		}
	\end{algorithm}
\end{algoritmo*}
Siccome per ogni elemento di $ v_1 $ devo scorrere interamente $ v_2 $, dovro ripetere $ v_2 * v_1 $ volte il body del ciclo.
\vskip3mm
In questo caso, se i due vettori hanno dimensione $ n $, si dice che la complessità dell'algoritmo è $ \Theta \left(n^2 \right) $

\subsubsection*{Notazione $ \Omega $, $ \Theta $, $ O $}
In generale, per valutare la complessità di un algoritmo siamo interessati a più scenari:
\begin{itemize}
	\item Nel peggiore dei casi, l'algoritmo che complessità ha? $ \rightarrow  $ notazione $ O $
	\item Nel migliore dei casi, l'algoritmo che complessità ha?$ \rightarrow  $ notazione $ \Omega  $
	\item Nel "caso medio", l'algoritmo che complessità ha?$ \rightarrow  $ notazione $ \Theta $
\end{itemize}
Nota bene: nella maggio parte dei casi siamo interessati alla coplessità nel caso pessimo $ O $ in quanto non possiamo escludere che questo si presenti nel dataset.
\vskip3mm
Per capire meglio la differenza fra caso ottimo e caso pessimo prendiamo in analisi l'algoritmo di \textit{insertion sort}:

\begin{algoritmo*}{Insertion Sort}
	\begin{algorithm}[H]
		\SetKwFunction{InsertSort}{insertionSort}
		\Fn{\Int \InsertSort{$\Int\ v[]$}}{
			\For{$i = 1$ \KwTo $v.size - 1$}{
				$\Int\ key = v[i]$\;
				$\Int\ j = i - 1$\;
				\While{$j \geq 0$  \And  $v[j] > key$}{
					$v[j + 1] = v[j]$\;
					$j = j - 1$\;
				}
				$v[j + 1] = key$\;
			}
			\Return{$v$}\;
		}
	\end{algorithm}
\end{algoritmo*}
In questo caso, dato un vettore lungo $ n $, abbiamo due casi estremi:
\begin{itemize}
	\item Il vettore è ordinato in modo crescente
	\item Il vettore è ordinato in modo decrescente
\end{itemize}
Nel primo caso l'algoritmo non entrerà mai nel ciclo while e dunque scorrerà il vettore una singola volta, originando una compessità di $ \Omega \left(n\right) $.
\vskip3mm
Nel secondo caso l'algoritmo dovrà per ogni elemento del vettore scorrere (quasi) tutto il vettore stesso, originando una complessità di $ O\left(n^2 \right) $

\subsection{Struttura problemi}
Ogni problema delle OII e delle OIS ha una struttura simile e si compone come segue:
\begin{itemize}
	\item Descrizione problema
	\item Descrizione dati di input
	\item Descrizione formato output
	\item Esempi
	\item Testcase
\end{itemize}
In particolare, il punteggio viene assegnato in base ai testcase che il nostro codice passa. Dobbiamo quindi scrivere un codice che risolva un dato problema stampando in output la soluzione. La correzione funziona come segue:
\begin{itemize}
	\item I testcase sono raggruppati in un dato numero di \textit{gruppi}
	\item Ad ogni gruppo di \textit{testcase} è assegnato un punteggio e delle assunzioni. Ad esempio, ci può essere detto che i dati in input, in un dato gruppo non superano una certa dimensione o sono strutturati in un modo particolare
	\item Se all'interno di un gruppo i testcase sono tutti passati (output corretto), allora vengono assegnati i punti, altrimenti no
\end{itemize}
Si noti che per passare un testcase non è sufficiente che l'output sia corretto, ma il tempo di esecuzione e la memoria utilizzata devono essere entro i limiti previsti, specificati nel testo del problema

\section{Programmazione dinamica}

\subsection{Donimo}
Quanti modi ho di disporre tasselle di domino in una scacchiera $ 2 \times n $?

\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Salvo in $ dp\left[i\right] $ il numero di combinazioni che ci sono per un rettangolo $ 2 \times i $
	\item Ho due opzioni:
	      \begin{itemize}
		      \item Metto 2 tessere in orizzontale, allora $ dp\left[i\right] = dp\left[i-2\right] $
		      \item Metto 1 tessera in verticale, allora $ dp\left[i\right] = dp\left[i-1\right] $
	      \end{itemize}
	\item Quindi $ dp\left[i\right] = dp\left[i-1\right] + dp\left[i-2\right] $
	\item La soluzione è $ \operatorname{Fib}\left(n\right) $
\end{itemize}
\subsection{Hateville}
Ho un vettore di prezzi. Se prendo un prezzo $ v\left[i\right] $ non posso prendere $ v\left[i-1\right] $ e $ v\left[i+1\right] $. Trova prezzo massimo

\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Salvo in $ dp\left[i\right] $ il prezzo massimo che posso ottenere con i vicini $ \le i $
	\item Ho due opzioni:
	      \begin{itemize}
		      \item Non prendo $ v\left[i\right] $, allora il prezzo è $ dp\left[i-1\right] $
		      \item Prendo $ v\left[i\right] $, allora il prezzo è $ dp\left[i-1\right] + v\left[i\right] $
	      \end{itemize}
\end{itemize}
\subsection{Zaino}\label{zaino}
Zaino ha capacità $ C $, ho $ n $ pezzi di peso $ w\left[i\right] $ e profitto $ p\left[i\right] $. Trova profitto massimo

\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Crea matrice $ n \times C $ in cui si salva $ dp\left[i\right]\left[j\right] $ il profitto massimo che si può ottenere con i pezzi $ \le i $ e capacità $ \le j $
	\item Ho due opzioni:
	      \begin{itemize}
		      \item Prendo pezzo $ \left(i,j\right) $, allora il prezzo migliore è $ dp\left[i-1\right]\left[j - w\left[i\right]\right] + p\left[i\right] $
		      \item Non lo prendo, allora il prezzo è $ dp\left[i-1\right]\left[j\right] $
	      \end{itemize}
	\item Posso ottimizzare lo spazio tenendo salvato solo due righe della matrice, la $ i $ e la $ i-1 $
\end{itemize}
\subsection{Zaino umbound}
Vedi \hyperref[zaino]{zaino}, solo che non c'è limite al numero di oggetti che uno puo prendere

\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Vettore $ dp $ in cui salvo in $ i $ il profitto massimo per uno zaino grande $ i $
	\item Per ogni peso item $ x $, il profitto massimo è $ p\left[x\right] + dp\left[i - w\left[x\right]\right] $
	\item $ dp\left[i\right] $ è il massimo fra tutti i valori trovati al punto 2
\end{itemize}
\subsection{LCS}
Date due stringhe $ U $ e $ T $, trova la \underline{sottosequenza} massimale. Una sottosequenza è una stringa che si ottiene da un'altra selezionandone solo alcuni caratteri (non necessariamente contigui, ma mantenendone l'ordine).
\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Tabella $ dp $ con $ U $ su un lato e $ T $ sull'altro. In $ dp\left[i\right]\left[j\right] $ salvo la lunghezza della $ LCS $ fra la sottostringa $ U\left[0,i\right] $ e $ T\left[0, j\right] $
	\item Ho due opzioni:
	      \begin{itemize}
		      \item $ U\left[i\right] = T[j] $, allora $ dp\left[i\right]\left[j\right] = dp\left[i-1\right]\left[j-1\right] +1 $ (aggiungo un carattere alla LCS più corta di 1)
		      \item $  U\left[i\right] \neq T[j] $  allora $ dp\left[i\right]\left[j\right] = \operatorname{max}\left(dp\left[i-1\right]\left[j\right], dp\left[i\right]\left[j-1\right]\right) $. Vedi immagine
	      \end{itemize}
\end{itemize}

\begin{center}
	\begin{tikzpicture}[scale=0.7]
		\draw [fill=mutedgreen!50](6, 0)rectangle ++ (2,1);
		\draw (0,0)grid(8,1);

		\draw [fill=mutedred!50](6, -3)rectangle ++ (4,1);
		\draw (0,-3)grid(10,-2);

		\begin{scope}[shift={(0.5,0.5)}]
			\node at (-1, 0) {$ U $};

			\node (1) at (0,0)  {a};
			\node (2) at (1,0)  {u};
			\node (3) at (2,0)  {t};
			\node (4) at (3,0)  {s};
			\node (5) at (4,0)  {s};
			\node (6) at (5,0)  {g};
			\node (7) at (6,0)  {n};
			\node (18) at (7,0)  {k};
			\node [anchor = south] at (7,0.5)  {$ i $};

			\node at (-1, -3) {$ V $};

			\node (8)  at (0,-3)  {w};
			\node (9)  at (1,-3)  {a};
			\node (10) at (2,-3)  {t};
			\node (11) at (3,-3)  {f};
			\node (12) at (4,-3)  {x};
			\node (13) at (5,-3)  {m};
			\node (14) at (6,-3)  {g};
			\node (15) at (7,-3)  {o};
			\node (16) at (8,-3)  {i};
			\node (17) at (9,-3)  {m};
			\node [anchor = south] at (6,-2.5)  {$ j $};
			% \node (15) at (7,-3)  {o};
			% \node (16) at (8,-3)  {i};

		\end{scope}

		\node (lcs)[circle] at (2,-1) {lcs};

		\draw (lcs)edge(1.south) edge (3.south) edge(6.south);
		\draw (lcs)edge(9.north) edge (10.north) edge(14.north);

	\end{tikzpicture}
\end{center}

Per migliorare la soluzione, se i caratteri sono diversi, devo aggiungere un carattere che sia nell'insieme dei caratteri dopo l'ultimo carattere comune. Quindi ho che
\begin{itemize}
	\item A $ T $, devo aggiungere un carattere che appartiene all'insieme rosso
	\item A $ U $, devo aggiungere un carattere che appartiene all'insieme verde
\end{itemize}
Chiaramente la cosa è asimmetrica, per questo devo controllare $ dp\left[i-1\right]\left[j\right] $ e $ dp\left[i\right]\left[j-1\right] $
\vskip3mm
\sfblue{Dimostrazione formale}: dobbiamo dimostrare che date due parole $ U \left(u_1,\ldots ,u_i\right) $ e $ V\left(v_1 , \ldots v_j\right) $ e $ X \left(x_1 , \ldots x_k\right) $ allora
\begin{itemize}
	\item Se $ u_i = v_j $  allora
	      \begin{gather*}
		      u_i = v_j = x_k \\
		      X\left(K-1\right) \in \mathcal{LCS}\left(U\left(i-1\right), V\left(j-1\right)\right)
	      \end{gather*}
	\item Se $ u_i \neq v_j $ e $ x_k \neq  u_i $ allora
	      \[
		      X \in \mathcal{LCS}\left(U\left(i-1\right), V \right)
	      \]
	\item Se $ u_i \neq v_j $ e $ x_k \neq  v_j $ allora
	      \[
		      X \in \mathcal{LCS}\left(U, V\left(j-1\right) \right)
	      \]
\end{itemize}

\begin{minipage}[t]{0.48\textwidth}
	\begin{center}
		\begin{tikzpicture}[scale=0.7]
			\draw (0,0)grid(8,1);
			\draw [fill=mutedgreen!50](7, 0)rectangle ++ (1,1);

			\draw (0,-3)grid(7,-2);
			\draw [fill=mutedred!50](6, -3)rectangle ++ (1,1);

			\begin{scope}[shift={(0.5,0.5)}]
				\node at (-1, 0) {$ U $};

				\node (1) at (0,0)  {a};
				\node (2) at (1,0)  {u};
				\node (3) at (2,0)  {t};
				\node (4) at (3,0)  {s};
				\node (5) at (4,0)  {s};
				\node (6) at (5,0)  {g};
				\node (7) at (6,0)  {n};
				\node (17) at (7,0)  {k};
				\node [anchor = south] at (7,0.5)  {$ i $};

				\node at (-1, -3) {$ V $};

				\node (8)  at (0,-3)  {w};
				\node (9)  at (1,-3)  {a};
				\node (10) at (2,-3)  {t};
				\node (11) at (3,-3)  {f};
				\node (12) at (4,-3)  {x};
				\node (13) at (5,-3)  {m};
				\node (14) at (6,-3)  {g};
				\node [anchor = south] at (6,-2.5)  {$ j $};
				% \node (15) at (7,-3)  {o};
				% \node (16) at (8,-3)  {i};

			\end{scope}

			\node (lcs)[circle] at (2,-1) {lcs};

			\draw (lcs)edge(1.south) edge (3.south) edge(6.south);
			\draw (lcs)edge(9.north) edge (10.north) edge(14.north);

		\end{tikzpicture}
	\end{center}
\end{minipage}
%
\begin{minipage}[t]{0.48\textwidth}
	\begin{center}
		\begin{tikzpicture}[scale=0.7]

			\draw (0,0)grid(6,1);
			\draw [fill=mutedblue!50](5, 0)rectangle(6,1);

			\draw (0,-3)grid(7,-2);
			\draw [fill=mutedblue!50](6, -3)rectangle(7,-2);

			\begin{scope}[shift={(0.5,0.5)}]
				\node at (-1, 0) {$ U $};

				\node (1) at (0,0)  {a};
				\node (2) at (1,0)  {u};
				\node (3) at (2,0)  {t};
				\node (4) at (3,0)  {s};
				\node (5) at (4,0)  {s};
				\node (6) at (5,0)  {g};
				\node [anchor = south] at (5,0.5)  {$ i $};

				\node at (-1, -3) {$ V $};

				\node (8)  at (0,-3)  {w};
				\node (9)  at (1,-3)  {a};
				\node (10) at (2,-3)  {t};
				\node (11) at (3,-3)  {f};
				\node (12) at (4,-3)  {x};
				\node (13) at (5,-3)  {m};
				\node (14) at (6,-3)  {g};
				\node [anchor = south] at (6,-2.5)  {$ j $};
				% \node (15) at (7,-3)  {o};
				% \node (16) at (8,-3)  {i};

			\end{scope}

			\node (lcs)[circle] at (2,-1) {lcs};

			\draw (lcs)edge(1.south) edge (3.south) edge(6.south);
			\draw (lcs)edge(9.north) edge (10.north) edge(14.north);

		\end{tikzpicture}
	\end{center}
\end{minipage}


\subsection{Occorrenza k approssimata}
Data una stringa $ t $ e una $ p $, diciamo che la distanza $ k $ di $ p $ da $ t $ è il numero \underline{minimo} di \textit{inserimenti, eliminazioni e scambi} che dobbiamo fare in $ t $ per far si che $ t == p $.
\[
	t = \text{ "scempio" }, \quad p = \text{ esempio } \rightarrow k = 2
\]
ad esempio, scambiando la "s" e "c" di \textit{scempio} in "e" ed "s" rispettivamente
\vskip3mm
Il problma sta nel trovare in un testo $ t $, la distanza minima di un pattern $ p $ da una sua qualsiasi sottostringa.
\vskip3mm
Ciò equivale a trovare quanti inserimenti, rimozioni e scambi devo fare \underline{nel testo} per far si che il pattern diventi una sua sottostringa
\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Inizializza matrice che ha $ p $ in verticale e $ t $ in orizzontale
	\item In $ dp\left[i\right]\left[j\right] $ si salva \textit{il minor valore di k per far si che $ p\left[0, i\right] $ sia sottostringa di $ t\left[0, j\right] $ che finisca in $ j $}
	\item Se $ p\left[i\right] == t\left[j\right] $ allora non serviranno altre mosse per riportare la soluzione di $ dp\left[i-1\right]\left[j-1\right] $ alla soluzione corrente
	\item Se $ p\left[i\right] \neq  t\left[j\right] $  allora posso fare 3 cose:
\end{itemize}

\begin{center}
	% \includegraphics{images/K approx.pdf }
	\begin{tikzpicture}[scale=0.6]

		\begin{scope}
			\draw [fill=mutedred!50](1,4)rectangle(4,3);
			\draw [fill=mutedgreen!50](0,0)rectangle(1,3);

			\draw (0,0)grid(7,4);

			\draw [thick, mutedblue](0,0)rectangle(1,3);
			\draw [thick, mutedblue](1,4)rectangle(3,3);

			\begin{scope}[shift={(0.5,0.5)}]
				\node at (0,2){b};
				\node at (0,1){a};
				\node at (0,0){b};

				\node at (1,3){a};
				\node at (2,3){b};
				\node at (3,3){a};
				\node at (4,3){b};
				\node at (5,3){a};
				\node at (6,3){g};

				\node at (3,0){?};
				\node at (2,0){$ \rightarrow $};

				% \node at[3,0] {Fai coincidere bab con ab e poi elimina a};
				\node at (3,-1) {+1};
				\node [align = center] at (3,-2) {Fai coincidere bab con ab\\ e poi elimina a};
			\end{scope}
		\end{scope}

		\begin{scope}[shift={(8,0)}]
			\draw [fill=mutedred!50](1,4)rectangle(4,3);
			\draw [fill=mutedgreen!50](0,0)rectangle(1,3);

			\draw (0,0)grid(7,4);

			\draw [thick, mutedblue](0,1)rectangle(1,3);
			\draw [thick, mutedblue](1,4)rectangle(4,3);

			\begin{scope}[shift={(0.5,0.5)}]
				\node at (0,2){b};
				\node at (0,1){a};
				\node at (0,0){b};

				\node at (1,3){a};
				\node at (2,3){b};
				\node at (3,3){a};
				\node at (4,3){b};
				\node at (5,3){a};
				\node at (6,3){g};

				\node at (3,0){?};
				\node at (3,1){$ \downarrow $};

				\node at (3,-1) {+1};
				\node [align = center] at (3,-2) {Fai coincidere ba con aba\\ e poi aggiungi b};
			\end{scope}
		\end{scope}

		\begin{scope}[shift={(16,0)}]
			\draw [fill=mutedred!50](1,4)rectangle(4,3);
			\draw [fill=mutedgreen!50](0,0)rectangle(1,3);

			\draw (0,0)grid(7,4);

			\draw [thick, mutedblue](0,1)rectangle(1,3);
			\draw [thick, mutedblue](1,4)rectangle(3,3);

			\begin{scope}[shift={(0.5,0.5)}]
				\node at (0,2){b};
				\node at (0,1){a};
				\node at (0,0){b};

				\node at (1,3){a};
				\node at (2,3){b};
				\node at (3,3){a};
				\node at (4,3){b};
				\node at (5,3){a};
				\node at (6,3){g};

				\node at (3,0){?};
				\node at (2,1){$ \searrow $};

				\node at (3,-1) {+1};
				\node [align = center] at (3,-2) {Fai coincidere ba con ab\\ e poi cambia a in b};
			\end{scope}
		\end{scope}

	\end{tikzpicture}
\end{center}

La soluzione migliore è data dal minimo valore nell'ultima riga della tabella
\vskip3mm
Nota che la prima riga e la prima colonna vanno riempite rispettivamente con $ \left[0,\ldots , 0\right] $ e $ \left[1,2,\ldots , n-1, n\right] $. Questo ha senso in quanto:
\begin{itemize}
	\item Per far si che il pattern vuoto sia sottostringa di $ t $ non serve alsona mossa ($ \left[0,\ldots ,0\right] $)
	\item Per far sic che un pattern di lunghezza $ k $ sia sottostringa del testo vuoto è necessario aggiungere i $ k $ caratteri del pattern ($ \left[1,2,\ldots , n-1, n\right] $)
\end{itemize}
\subsection{Prodotto di catena di matrici}
Si vuole fare il prodotto matriciale tra $ \left[A_1, A_2,  \ldots, A_{n-1}, A_n \right] $. Il prodotto matriciale gode di proprietà associativa. Si trovi la parentizzazione che riduce al minimo il numero di moltiplicazioni scalari totali da compiere
\vskip3mm
Ad esempio, avendo $ \left[A, B, C, D\right] $, posso parentizzare come segue:
\[
	\left[\left(A \cdot B\right) \cdot \left(C \cdot D\right)\right], \quad \left[A \cdot \left(B \cdot C \right) \cdot D\right], \quad \left[A \cdot \left(B \cdot \left(C  \cdot D\right)\right)\right]
\]
e cosi via. Questo funziona in quanto per moltiplicare delle matrici bisogna assicurarsi che queste siano compatibili. Il numero di colonne della prima deve essere uguale al numero di righe della seconda. Ad esempio, indicando con $ \left[\text{righe}, \text{colonne}\right] $ una matrice, una serie che può essere moltiplicata è la seguente:
\[
	\left[4,5\right] \cdot \left[5, 2\right] \cdot \left[2, 10\right]  \cdot \left[10, 7\right] \rightarrow \left[4,5,2,10,7\right]
\]
\vskip3mm
Nota che la dimensione di ogni matrice può essere salvata in un vettore $ c $ in cui $ c_i $ contiene il numero di colonne della matrice $ i $, che corrisponde al numero di righe della matrice $ i+1 $. Quindi il numero di moltiplicazioni necessarie per eseguire $ A_i \times A_j $ sarà:
\[
	c_i \cdot (\cdot c_{i-1} \cdot c_j)
\]
\begin{itemize}
	\item $ c_i $: numero di moltiplicazioni per calcolare una cella
	\item $ (\cdot c_{i-1} \cdot c_j) $: dimensione della matrice risultante
\end{itemize}
\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Creo matrice \verb|dp| come seguen:
	      \begin{center}
		      \begin{tabular}{|c|c|c|c|c|c|c|}
			      \hline
			        & 1 & 2 & 3 & 4 & 5 & 6 \\
			      \hline
			      1 & 0 &   &   &   &   &   \\
			      \hline
			      2 & - & 0 &   &   &   &   \\
			      \hline
			      3 & - & - & 0 &   &   &   \\
			      \hline
			      4 & - & - & - & 0 &   &   \\
			      \hline
			      5 & - & - & - & - & 0 &   \\
			      \hline
			      6 & - & - & - & - & - & 0 \\
			      \hline
		      \end{tabular}
	      \end{center}
	\item In \verb|dp[i][j]| salvo il minor numero di moltiplicazioni necessarie per moltiplicare le matrici fra \verb|i|  e \verb|j|
	\item Costruisco matrice scorrento in diagonale a partire dalla diagonale più vicina alla diagonale principale. Il numero minore è dato dal numero minore date due parentizzazioni, ad esempio se ho
	      \[
		      \left[A_3,A_4,A_5, A_6\right]
	      \]
	      dovro tentare con
	      \[
		      \left[\left(A_3\right) \cdot  \left(A_4, A_5, A_6\right)\right], \quad \left[\left(A_3, A_4\right) \cdot  \left(A_5, A_6\right)\right], \quad \left[\left(A_3, A_4, A_5\right) \cdot  \left(A_6\right)\right]
	      \]
	\item Il risultato finale si trova in \verb|dp[1][n]|, dove \verb|n| è il numero di matrici
	\item Per ricostruire la parentizzazione, posso salvarmi in una tabella \verb|last[i][j]| l'indice a cui ho "spezzato la parentizzazione". Poi posso ricostruirla ricorsivamente come segue:
\end{itemize}

\begin{algoritmo}{Find minimum parenthesization}
	\begin{algorithm}[H]
		\caption{Print optimal parenthesization}
		\SetKwFunction{FPrintPar}{printPar}
		\Fn{\FPrintPar{$\text{int}\ last[][],\ \text{int}\ i,\ \text{int}\ j$}}{
		\If{$i == j$}{
		\Print "A["; \Print $i$; \Print "]"\;
		}
		\Else{
			\Print "("\;
			\FPrintPar{$last,\ i,\ last[i][j]$}\;
			\Print "."\;
			\FPrintPar{$last,\ last[i][j]+1,\ j$}\;
			\Print ")"\;
		}
		}
	\end{algorithm}
\end{algoritmo}
\subsection{Intervalli pesati}\label{intervalli pesati}
Vengono dati $ n $ intervalli aperti $ \left[a_1, b_1\right[, \left[a_2, b_2\right[ , \ldots  \left[a_n, b_n\right[ $. Ogni intervalli ha un valore $ w_i $. Trovare il valore massimo che si può ottenere selezionando intervalli \underline{non sovrapposti}.

\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Ordina intervalli per \underline{tempo di fine}
	\item Definisco la funzione \verb|pred(i)|, che ritorna il \textit{predecessore} di un intervallo, ossia il primo intervallo che ha tempo di fine minore del tempo di inizio di $ i $
	\item Creo vettore \verb|dp| che salva in \verb|i| \underline{il valore massimo ottenibile con gli intervalli fino ad {\ttfamily i}} compreso
	\item Itero su intervalli. Per ciascun intervallo \verb|i| posso:
	      \begin{itemize}
		      \item Selezionarlo: in questo il valore massimo ottenibile è dato da {\ttfamily dp[pred(i)] + $ \text{w}_{\text{i}} $} a
		      \item \underline{Non} selezionarlo: in questo caso il valore massimo è uguale al precedente {\ttfamily dp[i-1]}
	      \end{itemize}
\end{itemize}
Complessità: $ O\left(n \log n\right) $

\section{Problemi sito oii consigliati}\label{problemi oii}
Di seguito una raccolta di problemi provenienti dal sito degli allenamenti della OII. Sono proposte delle soluzioni in sezione \cref{soluzioni problemi oii}

\begin{center}
	\begin{tabular}{l l l l}
		\toprule
		Problema                                                                                                     & Tecniche               & Difficoltà                                        & Soluzione               \\
		\midrule
		Figonacci {(\texttt{\href{https://training.olinfo.it/task/ois_figonacci}{figonacci}})}                       & dp                     & \ding{72} \ding{73} \ding{73} \ding{73} \ding{73} & \cref{sol figonacci}    \\
		Discesa massima {(\protect{\texttt{\href{https://training.olinfo.it/task/discesa}{discesa}}})}               & dp                     & \ding{72} \ding{73} \ding{73} \ding{73} \ding{73} & \cref{sol discesa}      \\
		Police 3 {(\protect{\texttt{\href{https://training.olinfo.it/task/ois_police3}{\ttfamily police3}}})}        & dp                     & \ding{72} \ding{73} \ding{73} \ding{73} \ding{73} & \cref{sol police3}      \\
		Piano degli studi {(\protect{\texttt{\href{https://training.olinfo.it/task/ois_pianostudi}{pianostudi}}})}   & dp, binary search      & \ding{72} \ding{72} \ding{72} \ding{73} \ding{73} & \cref{sol pianostudi}   \\
		Spiedini di frutta {(\protect{\texttt{\href{https://training.olinfo.it/task/oii_spiedini}{spiedini}}})}      & dp                     & \ding{72} \ding{72} \ding{73} \ding{73} \ding{73} & \cref{sol spiedini}     \\
		K-step ancestor {(\protect{\texttt{\href{https://training.olinfo.it/task/ois_treeancestor}{treeancestor}}})} & dp, graph              & \ding{72} \ding{72} \ding{73} \ding{73} \ding{73} & \cref{sol treeancestor} \\
		Taglialegna {(\protect{\texttt{\href{https://training.olinfo.it/task/oii_taglialegna}{taglialegna}}})}       & dp, amortized analysis & \ding{72} \ding{72} \ding{72} \ding{72} \ding{72} & \cref{sol taglialegna}  \\
		\bottomrule
	\end{tabular}
\end{center}
\newpage

\section{Soluzioni problemi sito OII}\label{soluzioni problemi oii}
Di seguito una raccolta di soluzioni per i problemi proposti in \cref{problemi oii}. Per ogni problema è riportato il link alla pagina del problema e il link alla soluzione proposta in questa dispensa.
\subsection{Figonacci {(\protect\texttt{\href{https://training.olinfo.it/task/ois_figonacci}{figonacci}})}}
\label{sol figonacci}
\begin{center}
	\begin{tabularx}{\textwidth}{X r}
		\toprule
		Problema sito OII  & \url{https://training.olinfo.it/task/ois_figonacci}                       \\
		Soluzione proposta & \ttfamily\href{run:./files/esercizi/figonacci/}{files/esercizi/figonacci} \\
		\bottomrule
	\end{tabularx}
\end{center}
L'idea qui è di "srotolare" la sommatoria, rendendosi conto che
\begin{align*}
	G_n & = \sum_{i=0}^{i=n-2} G_{n-1} - G_i                                                                                                       \\
	    & = \left(G_{n-1} - G_{n-2}\right) + \left(G_{n-1} - G_{n-3}\right) + \ldots + \left(G_{n-1} - G_{1}\right) + \left(G_{n-1} - G_{0}\right) \\
	    & = \left(n-1\right) G_{n-1} - \sum_{i=0}^{i = n-2} G_{i}                                                                                  \\
	    & = \left(n-1\right) G_{n-1} + G_{n-1}-\left(n-2\right)G_{n-2} - G_{n-2}                                                                   \\
	    & = \left(n-1\right) G_{n-1} - \left(n-1\right)f\left(n-2\right) + G_{n-1}                                                                 \\
	    & = \left(n-1\right)  \left(G_{n-1} - G_{n-2}\right) + G_{n-1}
\end{align*}
abbiamo così ottenuto a tutti gli effetti una formula che possiamo applicare direttamente in forma ricorsiva(con \textit{memoization}) o iterativa:
\begin{center}
	\ttfamily
	dp[i] = (i-1)(dp[i-1]*dp[i-2]) + dp[i-1]
\end{center}

\subsection{Discesa massima {(\protect{\texttt{\href{https://training.olinfo.it/task/discesa}{discesa}}})}}
\label{sol discesa}
\begin{center}
	\begin{tabularx}{\textwidth}{X r}
		\toprule
		Problema sito OII  & \url{https://training.olinfo.it/task/discesa}                         \\
		Soluzione proposta & \ttfamily\href{run:./files/esercizi/discesa/}{files/esercizi/discesa} \\
		\bottomrule
	\end{tabularx}
\end{center}
L'idea in questo caso è di creare un albero di discesa in cui in ogni posizione \verb|[i][j]| salviamo \textit{il maggior peso di una discesa che termina nella posizione \texttt{[i][j]}}.
\vskip3mm
Ad esempio, qui sotto è riportato a destra l'albero \verb|dp| per l'albero in input di sinistra
\[
	\begin{array}{c}
		1                       \\
		2 \quad  9              \\
		3 \quad 7\quad 5        \\
		8 \quad4\quad 11\quad 6 \\
	\end{array}
	\quad
	\rightarrow
	\quad
	\begin{array}{c}
		1                            \\
		3 \quad  10                  \\
		6 \quad 17\quad 15           \\
		14 \quad 21\quad 28 \quad 21 \\
	\end{array}
\]
rimane da capire come calcolare i valori nella file $ i $ esima basandosi sui precedenti. In particolare abbiamo 3 casi:
\begin{itemize}
	\item \textit{Primo elemento}: posso arrivare \textit{solo da destra}, quindi:
	      \begin{center}
		      \verb|dp[i][0]=dp[i-1][0] + w[i][0]|
	      \end{center}
	\item \textit{Ultimo elemento}: posso arrivare \textit{solo da sinistra}, quindi
	      \begin{center}
		      \verb|dp[i][size]=dp[i-1][size-1] + w[i][size]|
	      \end{center}
	\item \textit{Elemento in mezzo}: posso arrivare sia da sinistra che da destra, quindi dovro prendere la strada che fra le due ha peso maggiore:
	      \begin{center}
		      \verb|dp[i][j]=w[i][j] + max(dp[i][j], dp[i][j+1])|
	      \end{center}
\end{itemize}
Chiaramente il caso base è quello riguardante il primo elemento, per cui il persorso di peso massimo è dato dal peso dell'elemento stesso.
\vskip3mm
Occorre ragionare un filo meglio sugli indici ma la logica rimane inalterata. Nota bene: \textit{è veramente necessario salvare l'intera matrice dp?}


\subsection{Police 3 {(\protect{\texttt{\href{https://training.olinfo.it/task/ois_police3}{\ttfamily police3}}})}}
\label{sol police3}
\begin{center}
	\begin{tabularx}{\textwidth}{X r}
		\toprule
		Problema sito OII  & \url{https://training.olinfo.it/task/ois_police3}                     \\
		Soluzione proposta & \ttfamily\href{run:./files/esercizi/discesa/}{files/esercizi/police3} \\
		\bottomrule
	\end{tabularx}
\end{center}
L'idea qui è, per quanto banale possa semprare, ad ogni semaforo abbiamo due opzioni: fermarsi o meno. Per questa ragione possiamo salvare informazioni in due vettori \verb|dp|, per ciascuno dei due casi:
\begin{itemize}
	\item \verb|ts[i]|: salva in $ i $ il minor tempo per superare il semaforo $ i $ fermandosi a quest'ultimo
	\item \verb|tr[i]|: salva in $ i $ il minor tempo per superare il semaforo $ i $, scappando
\end{itemize}
possiamo costruire i valori dei due vettori basandoci sui precedenti secondo la seguente logica
\begin{itemize}
	\item Se \textit{mi fermo} al semaforo $ i $-esimo, il tempo ideale sarà dato dall'attesa al semaforo + il tempo migliore ottenuto fermandosi o meno a quello precedente (posso scegliere di fermarmi oppure no, siccome non violo nessun vincolo in ogni caso)
	      \begin{center}
		      \ttfamily
		      ts[i] = T[i] + min(tr[i - 1], ts[i - 1]);
	      \end{center}
	\item Se \textit{non mi fermo} al semaforo $ i $-esimo, il tempo ideale sarà dato dal tempo ideale per arrivare al semaforo $ i-1 $, fermandocisi (in questo caso devo assicurarmi di fermarmi al semaforo precedente per non violare alcun vincolo)
	      \begin{center}
		      \ttfamily
		      tr[i] = ts[i - 1];
	      \end{center}
\end{itemize}
Anche in questo caso, è davvero necessario salvare l'interi vettori in memoria?

\subsection{Piano degli studi {(\protect{\texttt{\href{https://training.olinfo.it/task/ois_pianostudi}{pianostudi}}})}}
\label{sol pianostudi}
\begin{center}
	\begin{tabularx}{\textwidth}{X r}
		\toprule
		Problema sito OII  & \url{https://training.olinfo.it/task/ois_pianostudi}                        \\
		Soluzione proposta & \ttfamily\href{run:./files/esercizi/pianostudi/}{files/esercizi/pianostudi} \\
		\bottomrule
	\end{tabularx}
\end{center}

\subsection{Police 4 {(\protect{\texttt{\href{https://training.olinfo.it/task/ois_police4}{\ttfamily police4}}})}}
\label{sol police4}
\begin{center}
	\begin{tabularx}{\textwidth}{X r}
		\toprule
		Problema sito OII  & \url{https://training.olinfo.it/task/ois_police4}                     \\
		Soluzione proposta & \ttfamily\href{run:./files/esercizi/police4/}{files/esercizi/police4} \\
		\bottomrule
	\end{tabularx}
\end{center}
L'idea in questo caso è di salvare di volta il tempo minimo per arrivare al semaforo \verb|i| avendone saltati al più \verb|j|. Questa informazione può essere mantenuta in una matrice $ n \times r $, dove $ n $ è il numero di \textit{semafori} e $ r $ il numero massimo di semafori che \textit{possono essere saltati}.
\vskip3mm
La $ i $-esima colonna/riga della matrice può essere calcolata usando la precedente. In particolare, supponiamo di voler calcolare il tempo minore per arrivare al semaforo $ i $ saltandone al più $ j $. Allora ho due opzioni:
\begin{itemize}
	\item Arrivo al semaforo $ i-1 $ saltandone al massimo $ j-1 $. In questo caso il tempo ideale è quello ottenuto saltando il semaforo $ i-1 $
	\item Arrivo al semaforo $ i-1 $ saltandone al più $ j $. In questo caso devo controllare se devo aspettare o meno. In caso affermativo devo aggiungere il tempo di attesa alla soluzione
\end{itemize}
La soluzione ottimale è data dalla migliore delle due. Formarlmente dati $ T $ e $ X $, rispettivamente l'intervalli dei semafori e il vettore delle posizioni, posso calcolare \verb|dp| come segue:
\begin{center}
	\begin{lstlisting}[language = cpp, frame = none]
  t1 = dp[i-1][j-1];
  t2 = dp[i-1][j] + (can_pass ? 0 : T-dp[i-1][j] % T);
  dp[i][j] = min(t1, t2) + X[i] - X[i-1];
\end{lstlisting}
\end{center}
\begin{center}
	\ttfamily
\end{center}

\subsection{Spiedini di frutta {(\protect{\texttt{\href{https://training.olinfo.it/task/oii_spiedini}{spiedini}}})}}
\label{sol spiedini}
\begin{center}
	\begin{tabularx}{\textwidth}{X r}
		\toprule
		Problema sito OII  & \url{https://training.olinfo.it/task/oii_spiedini}                      \\
		Soluzione proposta & \ttfamily\href{run:./files/esercizi/spiedini/}{files/esercizi/spiedini} \\
		\bottomrule
	\end{tabularx}
\end{center}
L'idea è che una volta che uno spiedino è stato mangiato fino ad un certo punto da una parte, allora la soluzione ideale è prefissata e consiste nel mangiarlo dalla parte opposta finchè è possibile. La chiave sta tuttavia nel comprendere che non è necessario calcolare tutta la somma da capo ad ogni iterazione, ma possiamo seguire questa logica:
\begin{itemize}
	\item Mangio lo spiedino \textit{da sinistra} fino all'ultima fragola che permette di \textit{non} superare la soglia. Tengo sempre traccia della soglia corrente
	\item Partendo \textit{da destra} mangio lo spiedino fino a quando la soglia lo permette
	\item Tengo traccia del numero di fragole mangiate
	      i
\end{itemize}
Dopodichè, ripeto questi step fino a quanto non raggiungo l'estremità sinistra dello spiedino:
\begin{itemize}
	\item Da sinistra, scorro fino alla fragola precedente, abbassando la soglia
	\item Da destra scorro fino all'ultima fragola che riesco ad includere, aggiornando soglia e quantità di fragole mangiate
\end{itemize}
La soluzione migliore ottenuta in ogni step dell'iterazione precedente è la soluzione ottimale al problema

\subsection{K-step ancestor {(\protect{\texttt{\href{https://training.olinfo.it/task/ois_treeancestor}{treeancestor}}})}}
\label{sol treeancestor}
\begin{center}
	\begin{tabularx}{\textwidth}{X r}
		\toprule
		Problema sito OII  & \url{https://training.olinfo.it/task/ois_treeancestor}                          \\
		Soluzione proposta & \ttfamily\href{run:./files/esercizi/treeancestor/}{files/esercizi/treeancestor} \\
		\bottomrule
	\end{tabularx}
\end{center}
La soluzione sta nell'esplorare l'albero tenendo traccia della profondità corrente e del tragitto che ha portato fino al nodo che stiamo attualmente visitato. Possiamo fare ciò tramite 2 variabili \verb|depth| e \verb|path[n]|
\vskip3mm
Dato che il grado in questo caso è semplicemente un albero, possiamo sfruttare anche una semplice \href{https://en.wikipedia.org/wiki/Depth-first_search}{DFS}, dato che possiamo essere sicuri che il path che ci porta a ciascun nodo è unico.
\vskip3mm
Per ciascun nodo, controlliamo se la depth è maggiore o minore di $ K $. Nel primo caso sfruttiamo l'array contenente il path per assegnare il valore del $ k $-ancestor, nel secondo semplicemente assegnamo -1. Formalmente:
\begin{lstlisting}[language = java, frame = none]
if (depth >= K) {
  ancestor[node] = path[depth - K];
} else {
  ancestor[node] = -1;
}
\end{lstlisting}
nella DFS chiamiamo ricorsivamente la funzione con un valore di \verb|depth| incrementato di 1 ogni volta

\subsection{Taglialegna {(\protect{\texttt{\href{https://training.olinfo.it/task/oii_taglialegna}{taglialegna}}})}}
\label{sol taglialegna}
\begin{center}
	\begin{tabularx}{\textwidth}{X r}
		\toprule
		Problema sito OII  & \url{https://training.olinfo.it/task/oii_taglialegna}                         \\
		Soluzione proposta & \ttfamily\href{run:./files/esercizi/taglialegna/}{files/esercizi/taglialegna} \\
		\bottomrule
	\end{tabularx}
\end{center}
Il problema è piuttosto avanzato, per questo è necessario fare delle osservazioni preliminari che torneranno utili dopo.
\begin{enumerate}
	\item In una soluzione ottima ho 3 opzioni:
	      \begin{enumerate}
		      \item L'ultimo albero a destra viene tagliato e fatto cadere a \textit{sinistra}
		      \item L'ultimo albero a destra viene tagliato e fatto cadere a \textit{destra}
		      \item L'ultimo albero a destra \textit{non} viene tagliato ma fatto cadere a \textit{destra} per "effetto domino"
	      \end{enumerate}
	      L'idea importante è che in una soluzione ottima l'ultimo albero a destra, se cade a sinistra è perchè è stato tagliato e fatto cadere a sinistra. Per quanto sia ovvio è molto importante per capire gli step successivi
	\item Gli unici punti in cui si può interrompere l'effetto domino sono i punti in cui vi sono alberi di altezza 1
	\item Per quanto detto al punto precedente, possiamo vedere il problema come una serie di intervalli che errano fatti cadere in una delle due direzioni. Agli estremi di questi intervalli ci sono alberi di altezza 1
	\item Quando avviene un effetto domino, non tutti gli alberi partecipano nella catena della caduta. In particolare un albero può essere abbattuto da un albero che non è quello precedente nella catena. Chiameremo questo albero \verb|ff|(first-falling) di \verb|i|. Possiamo quindi considerare l'effetto domino solo per gli alberi abbattitori, nel modo seguente:
	      \[
		      i \rightarrow \operatorname{ff}\left[i\right] \rightarrow \operatorname{ff}\left[\operatorname{ff}\left[i\right]\right] \rightarrow \ldots
	      \]
\end{enumerate}
Detto questo, individuiamo il sotto-problema di programmazione dinamica e il caso base. In particolare sappiamo che:
\begin{itemize}
	\item Il sotto-problema consiste nel calcolare il \textit{il numero minore di tagli} per abbattere gli alberi da 0 a i
	\item Il caso base è quanto $ n=1 $, ossia quando ho un solo albero. In questo caso la soluzione è fare un unico taglio
\end{itemize}
\hypertarget{taglialegna solution steps}{}Rimane ora capire come utilizzare le soluzioni ottime da 0 a $ i-1 $ per calcolare la $ i $-esima soluzione ideale. Possiamo ragionare così per calcolare la soluzione ottimale $ i $-esima:
\begin{itemize}
	\item Se l'albero viene \textit{tagliato a sinistra}, allora simulo l'effetto domino e verifico dove questo si interrompe. Supponendo che la catena abbia fatto cadere $ k $ alberi, allora
	      \begin{center}
		      \ttfamily
		      solution[i] = 1 + solution[i-k-1]
	      \end{center}
	\item Se l'albero viene \textit{tagliato a destra}, allora non rimane che pulire in maniera ottimale gli alberi da 0 a $ i-1 $, quindi:
	      \begin{center}
		      \ttfamily
		      solution[i] = 1 + solution[i-1]
	      \end{center}
	\item Se l'albero viene \textit{fatto cadere a destra}, allora all'interno della \textit{catena dei first-fall} devo capire quale albero è più conveniente tagliare per innescare l'effetto domino. Chiamando questo albero \verb|opt|, allora la soluzione ottimale è data da
	      \begin{center}
		      \ttfamily
		      solution[i] = 1 + solution[opt-1]
	      \end{center}
\end{itemize}
Andiamo ora ad elencare le strutture dati che ci aiuteranno nel calcolo progressivo del vettore \verb|solution|
\begin{itemize}
	\item \verb|lb[i]|: \textit{left-bound}, contiene nella posizione $ i $ l'indice fino al quali gli alberi cadono se l'albero $ i $ viene tagliato a \textit{sinistra}
	\item \verb|rb[i]|:\textit{right-bound}, contiene nella posizione $ i $ l'indice fino al quali gli alberi cadono se l'albero $ i $ viene tagliato a \textit{destra}
	\item \verb|ff[i]|: \textit{first-fall}, come descritto precedentemente, il primo albero alla sinistra di $ i $ che in un effetto a catena colpisce $ i $
\end{itemize}
\hypertarget{taglialegna dp data}{}Come vedremo, possiamo calcolare tutti questi vettori in tempo $ O\left(n\right) $

%int solution[n];

%// In which direction should I cut the last tree in order to obtain i-th
%// optimal solution: 0=left 1=right
%bool dir[n];

%// Saves the optimal spot to to start the domino effect when making the trees
%// fall to the right
%int opt_split[n];

%// Saves the first tree to cut in the i-th optimal solution
%int first_cut[n];

\begin{itemize}
	\item \verb|solution[i]|: il vettore \textit{dp} principale. Salva la soluzione ottimale per il range $ \left[0,i\right] $
	\item \verb|dir[i]|: il vettore che contiene la direzione in cui va tagliato il primo albero per ottenere la soluzione ottimale
	\item \verb|opt_split[i]|: \textit{optimal-split}, salva la posizione ottimale per dare inizio all'effetto domino nella soluzione migliore in cui l'ultimo albero cade a destra
	\item \verb|first_cut[i]|: salva l'indice del primo albero da tagliare nella $ i $-esima sotto soluzione ottimale
\end{itemize}
\hypertarget{taglialegna step 1}{}\sfblue{Parte 1:} calcolo \verb|lb|, \verb|rb|
\vskip3mm
Partiamo dal calcolo dei vettori \verb|lb| e \verb|rb|. L'idea è proprio quella di simulare a tutti gli effetti l'effetto domino. In particolare, pensiamo di avere una serie di intervalli che cadono per effetto domino e un albero che viene fatto cadere a sinistra:

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}
			\node (a)[whitedot, minimum width=1cm] at (0,0) {$ k_n $};
			\node (b)[whitedot, minimum width=1cm] at (2,0) {$k_{n-1}$};
			\node (c)[whitedot, minimum width=1cm] at (4,0) {$k_2$};
			\node (d)[whitedot, minimum width=1cm] at (6,0) {$k_1$};
			\node (e)[whitedot, minimum width=1cm] at (9,0) {$ i $};

			\draw [latex-latex, thick](a)--(b) node [midway, below]{$ n $};
			\draw [latex-latex, dashed](b)--(c) node [midway, below]{$ \ldots  $};
			\draw [latex-latex, thick](c)--(d) node [midway, below]{$ 2 $};
			\draw [latex-latex, thick](d)--(e) node [midway, below]{$ 1 $};

			\draw [-latex][ultra thick](e)--++(0,8);
			% \draw [latex-latex, thick](5,0)--(8,0) node [midway, below]{d};
			\draw [dashed, -latex](e)++(0,8)to[out=180, in = 90](1,0);
			\node[fit=(current bounding box.south west)(current bounding box.north east)] {};
		\end{tikzpicture}
	\end{center}
	\caption{Calcolo left-bound}
	\label{calcolo left bound}
\end{figure}
In questa figura, sappaimo già che gli intervalli da 1 a $ n $ cadono a sinistra per effetto domino, interrompendosi nei punti $ k_2, \ldots , k_n $. \verb|lb[i]| sarà quindi dato da valore più basso fra i \verb|lb| degli intervalli che l'albero abbatte sicuramente, ossia tutti gli intervalli il cui albero più a destra viene abbattuto dall'albero $ i $. In figura, questi sono precisamente gli intervalli $ 1, \ldots , n $. Più formalmente

\begin{algoritmo*}{Calcolo left-bound}
	\begin{algorithm}[H]
		\SetKwFunction{FComputeLeftBound}{compute\_left\_bound}
		\Fn{\Int$\left[\right]$ \FComputeLeftBound{$n, h$}}{
		\Int $ lb  \leftarrow $ \New \Int $[0\ldots n-1]$\;
		% \Int lb $ \leftarrow $ \New~\Int[n]\;
		\For{$i \leftarrow 0$ \KwTo $n-1$}{
		$lb[i] \leftarrow i$\;
		\While{$lb[i] > 0 \land lb[i] > i - h[i] + 1$}{
		$lb[i] \leftarrow lb[\,lb[i] - 1\,]$\;
		}
		}
		\Return{$lb$}\;
		}
	\end{algorithm}
\end{algoritmo*}
Il calcolo del vettore \verb|rb| è speculare, ma segue la medesima logica.
\vskip3mm
Ora è fondamentale discurete la complessità di questa funzione. Potremmo in un primo momento pensare \textit{erroneamente} che la funzione abbia complessità di $ O\left(n^2 \right) $, dato che il ciclo esterno scorre l'interno vettore e, nel caso peggiore, anche quello interno scorre tutti gli elementi da $ i $ a 0. Tuttavia, il ragionamento è un filo più sottile.
\vskip3mm
Diciamo che un albero viene \textit{saltato da $ i $} se all'interno del ciclo while che calcola \verb|lb[i]| viene utilizzato per aggiornare il valore di \textit{lower-bound}
\[
	lb[i] \leftarrow lb[\underbracket[0.1ex]{lb[i] - 1}_{\text{saltato}}]
\]
Aiutandoci con la figura \ref{calcolo left bound}, possiamo intuire che gli alberi saltati, nel calcolo di \verb|lb[i]|, sono dati da $ k_1, k_2, \ldots k_{n-1} $. La chiave sta nel capire che \underline{ogni albero può essere saltato una volta sola}. Questo avviene in quanto, supponendo che gli alberi $ k_1,\ldots k_{n - 1} $ vengano saltati dall'albero $ i $, allora nelle iterazioni successive questi non possono più essere saltati, in quanto al più verrà saltato prima l'albero $ i $, il quale avrà un \textit{left-bound} minore di $ k_{n-1} $, quindi tutto il range in cui stanno gli alberi $ k_1,\ldots k_{n-1} $ non verrà considerato nella computazione.
\vskip3mm
Quindi, ancora una volta, siccome ogni albero viene saltato una e una sola volta, la riga $ 	lb[i] \leftarrow lb[lb[i] - 1]$ del ciclo while viene eseguita al più $ n $ volte, portando ad una complessità totale di $ O\left(n\right) $
\vskip3mm
\hypertarget{taglialegna step 2}{}\sfblue{Parte 2:} calcolo \verb|ff|
\vskip3mm
Il calcolo di \verb|ff| può implementato in maniera piuttosto semplice con piccolissime modifiche alla funzione che calcola \verb|rb|. Sempre riferendoci a \cref{calcolo left bound}, possiamo notare che il primo albero ad abbattere gli alberi $ k_1,\ldots ,k_{n-1} $ in una catena di abbattitori è $ i $. Per questo motivo ogni volta che calcoliamo \verb|rb[i]| possiamo anche aggiornare il valore per \verb|ff| degli alberi $ k_1,\ldots k_{n-1} $. Formalmente:
\begin{algoritmo*}{Calcolo right-bound e first-fall}
	\begin{algorithm}[H]
		\SetKwFunction{FComputeRightBound}{compute\_rb\_ff}
		\Fn{\Int[] \FComputeRightBound{$n, h$}}{
			\Int $rb \leftarrow$ \New \Int $[0\ldots n-1]$\;
			\Int $ff \leftarrow$ \New \Int $[0\ldots n-1]$\;
			\For{$i \leftarrow n-1$ \Downto $0$}{
				$rb[i] \leftarrow i$\;
				$ff[i] \leftarrow -1$\;
				\While{$ rb[i] < n-1 $ \And $ rb[i] < i + h[i] - 1 $}{
					$ ff[rb[i] + 1] \leftarrow i $\;
					$ rb[i] \leftarrow rb[rb[i] + 1] $\;
				}
			}
			\Return{rb, ff}\;
		}
	\end{algorithm}
\end{algoritmo*}
La complessità rimane sempre $ O\left(n\right) $

\vskip3mm
\hypertarget{taglialegna step 3}{}\sfblue{Parte 3:} calcolo \verb|solution|
\vskip3mm
Innanzitutto, ci appoggeremo alle strutture dati \verb|dp| descritte \hyperlink{taglialegna dp data}{qui}. Per calcolare il vettore \verb|solution|, gli step sono, dal punto di vista logico, quelli descritti \hyperlink{taglialegna solution steps}{qui}. Descriviamo più nel dettaglio le 2 casistiche:
\begin{itemize}
	\item Taglio a sinistra:
	      \begin{lstlisting}[language = cpp, frame = none]
solution[i] = 1 + (lb[i] > 0 ? solution[lb[i] - 1] : 0);
opt_cut[i] = i;
dir[i] = 0;\end{lstlisting}%
	\item Albero cade a destra:
	      \begin{itemize}
		      \item Taglio a destra:
		            \begin{lstlisting}[language = cpp, frame = none]
solution[i] = 1 + (idx2 > 0 ? solution[i - 1] : 0);
\end{lstlisting}
		      \item Albero abbattuto a destra per effetto domino:
		            \begin{lstlisting}[language = cpp, frame = none]
split_index = opt_split[ff[i]]; // Optimal index to cut the tree
solution[i] = 1 + (idx1 > 0 ? solution[split_index - 1] : 0);
\end{lstlisting}
	      \end{itemize}
\end{itemize}
Ora ci rimane solo da aggiornare il vettore \verb|opt_cut|, così da rendere l'intero algoritmo efficiente. Anche qui la programmazione dinamica viene in nostro soccorso. Più in particolare, so che supponendo che la catena di $ k $ first fall che abbattono $ i $ sia composta dagli alberi $ 1,2,\ldots ,k-1,i $. Allora so già che fra i primi $ k-1 $ il migliore è dato da \verb|opt_split[k-1]|, non rimane che testare l'ultimo, ossia il caso in cui $ i $ è abbattuto a destra. Nel caso la soluzione migliore si ottenesse con la prima opzione, allora \verb|opt_split[i]=opt_split[ff[i]]|, altrimenti \verb|opt_split[i] = i|
\vskip3mm
Chiaramente, scorrendo ogni elemento del vettore una sola volta, la funzione ha complessità $ O\left(n\right) $

\begin{algoritmo*}{Calcolo soluzione}
	\begin{algorithm}[H]
		% \caption{Compute optimal cuts for trees (DP)}
		% \label{alg:forest-dp-func}

		% \KwIn{$n$, arrays $lb[1..n]$, $rb[1..n]$, $ff[1..n]$}
		% \KwOut{$solution[1..n]$, $first\_cut[1..n]$, $dir[1..n]$, $opt\_split[1..n]$}
		\SetKwFunction{FComputeSolution}{compute\_solution}
		\Fn{\FComputeSolution{$n, lb, rb, ff$}}{
			\vskip3mm
			$solution[0] \leftarrow 1$\;
			$dir[0] \leftarrow 1$\;
			$opt\_split[0] \leftarrow 0$\;
			$first\_cut[0] \leftarrow 0$\;

			\vskip3mm
			\For{$i \leftarrow 1$ \KwTo $n$}{
				\vskip3mm
				% Case 1: last tree is cut to the left
				\Comment{Case 1: last tree is cut to the left}
				$sol_{1} \leftarrow 1 + $\leIf{$ lb[i] > 0 $}{$solution[lb[i] - 1]$}{$0$}
				$cut_{1} \leftarrow i$\;
				$dir_{1} \leftarrow \KwFalse$\;

				\vskip3mm
				% Case 2: last tree falls to the right
				\Comment{Case 2: last tree falls to the right}
				\If{$ff[i] \neq -1$}{

					\vskip3mm
					% Case 2.1: tree falls for domino effect
					\Comment{Case 2.1: tree falls by domino effect}
					$idx_{1} \leftarrow opt\_split[ff[i]]$\;
					$sol_{21} \leftarrow 1 + $\leIf{$idx_{1} > 0$}{$solution[idx_{1} - 1]$}{$0$}

					\vskip3mm
					% Case 2.2: tree is cut to the right
					\Comment{Case 2.2: tree is cut to the right}
					$idx_{2} \leftarrow i$\;
					$sol_{22} \leftarrow 1 + $\leIf{$idx_{2} > 0$}{$solution[idx_{2} - 1]$}{$0$}

					\vskip3mm
					$opt\_split[i] \leftarrow $\leIf{$sol_{21} < sol_{22}$}{$ idx_{1} $}{$ idx_{2} $}
				}
				\Else{
					$opt\_split[i] \leftarrow i$\;
				}

				\vskip3mm
				$sol_{2} \leftarrow 1 + $\leIf{$opt\_split[i] > 0$}{$solution[opt\_split[i] - 1]$}{$0$}

				$cut_{2} \leftarrow opt\_split[i]$\;
				$dir_{2} \leftarrow \KwTrue$\;

				\vskip3mm
				% Saving better solution
				\If{$sol_{1} < sol_{2}$}{
					$solution[i] \leftarrow sol_{1}$\;
					$first\_cut[i] \leftarrow cut_{1}$\;
					$dir[i] \leftarrow dir_{1}$\;
				}
				\Else{
					$solution[i] \leftarrow sol_{2}$\;
					$first\_cut[i] \leftarrow cut_{2}$\;
					$dir[i] \leftarrow dir_{2}$\;
				}
			}

			\Return{$solution, first\_cut, dir$}\;
		}
	\end{algorithm}
\end{algoritmo*}

\vskip3mm
\hypertarget{taglialegna step 4}{}\sfblue{Parte 4:} ricostruire la soluzione
\vskip3mm
Una volta calcolati i vettori \verb|solution|, \verb|first_cut| e \verb|dir| è piuttosto immediato ricostruire la soluzione "risalendo" al contrario i tagli che sono stati fatti:
\begin{algoritmo}{Ricostruzione soluzione}
	\begin{algorithm}[H]

		\SetKwFunction{FReconstructSolution}{reconstruct\_solution}
		\SetKwFunction{FAbbatti}{abbatti}
		\Fn{\FReconstructSolution{$n, first\_cut, dir$}}{
			$pos \leftarrow n - 1$\;
			\While{$pos \ge 0$}{

				\FAbbatti{$first\_cut[pos], dir[pos]$}\;

				\If{$dir[pos] = \KwFalse$}{
					$pos \leftarrow lb[pos] - 1$\;
				}
				\Else{
					$pos \leftarrow first\_cut[pos] - 1$\;
				}
			}
		}
	\end{algorithm}
\end{algoritmo}
Complessivamente, abbiamo che
\begin{center}
	\begin{tabular}{l l l}
		\toprule
		Step                                   & task                                                 & complessità          \\
		\midrule
		\hyperlink{taglialegna step 1}{Step 1} & calcolo \verb|lb|, \verb|rb|                         & $ O\left(n\right) $  \\
		\hyperlink{taglialegna step 2}{Step 2} & calcolo \verb|ff|                                    & $ O\left(n\right) $  \\
		\hyperlink{taglialegna step 3}{Step 3} & calcolo \verb|solution|, \verb|dir|, \verb|best_cut| & $ O\left(n\right) $  \\
		\hyperlink{taglialegna step 4}{Step 4} & ricostruisco soluzione                               & $  O\left(n\right) $ \\
		\bottomrule
	\end{tabular}
\end{center}
Complessità totale: $ O\left(n\right) $

\end{document}
