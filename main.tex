%&../.preamble
\endofdump

\usetikzlibrary{external}
\tikzset{external/system call={pdflatex --shell-escape --fmt=../.preamble --halt-on-error -jobname "\image" "\endofdump\texsource"}}
\tikzexternalize[prefix=tikz/]

\title{Pelstra di algoritmi}
\author{Marini Mattia}
\date{20 ottobre 2025}

\begin{document}
\maketitle
\license{Palestra di algoritmi}
\tableofcontents
\newpage

\section{Introduzione}
Qui di seguito sono raccolte nozioni di base per affrontare ogni probrema relativo alle \textit{OII}

\subsection{Basi cpp}
In ogni problema è necessario effettuare input/output su file\footnote{In realtà a volte è sufficiente implementare il body di una funzione oppure la parte relativa all'output viene fornita}. Ci sono diversi modi per eseguire ciò.
\subsubsection{Input metodo 1 (consigliato)}
Vedi file \href{run:./files/teoria/input1/}{input1.cpp}
\vskip3mm
L'idea è di creare un oggeto \verb|ifstream| e \verb|ofstream| che poi potremmo utilizzare in maniera totalmente analoga a, rispettivamente, \verb|cin| e \verb|cout|
\begin{lstlisting}[language = cpp, frame = none]
std::ifstream in("input.txt");
in >> a >> b;

std::ifstream out("output.txt");
out << a << b
\end{lstlisting}
Esiste un trucco per velocizzare notevolmente la velocità di input/output utilizzando questo metodo. In particolare, è sufficiente appendere le seguenti righe prima di scrivere o leggere su files:
\begin{lstlisting}[language = cpp, frame = none]
ios_base::sync_with_stdio(false); 
cin.tie(NULL);
\end{lstlisting}
Tuttavia se il problema sfora i limiti di tempo, con ogni probabilità è la soluzione a non essere corretta, non le operazioni di input/output. Queste righe possono essere utili per scalare la classifica sui siti di allenamento, non per altro

\subsubsection{Input metodo 2}
Vedi file \href{run:./files/teoria/input/}{input2.cpp}
\vskip3mm
Questo metodo è più "vecchio" e meno consigliato. L'idea è di utilizzare le funzioni \verb|freopen| per reindirizzare lo standard input/output su file:
\begin{lstlisting}[language = cpp, frame = none]
FILE *in = fopen("input.txt", "r");
fscanf(in, "%d %d", &a, &b);

FILE *out = fopen("output.txt", "w");
fprintf(out, "%d %d\n", a, b);
\end{lstlisting}
dove le funzioni \verb|fprintf| e \verb|fscanf| prendono come argomenti:
\begin{itemize}
	\item Il puntatore ad un file \verb|FILE *|
	\item Una stringa \verb|format|, contenente una serie di specificatori, preceduti da "{\ttfamily \%}"
	      \begin{itemize}
		      \item \verb|d|: decimal, numero intero
		      \item \verb|f|: float
		      \item \verb|s|: stringa c-style, in particolare \verb|char *|
	      \end{itemize}
	\item Una serie variabili che corrispondono a quanto indicato in \verb|format|. Nel caso di \verb|scanf| è richiesto l'indirizzo di memoria di queset
\end{itemize}
\subsubsection{Ultra fast io}
Ci sono infine alcuni metodi per velocizzare l'input al massimo, utili per sprepere la perfomance al massimo, per arrivare nei primi in classifica. In particolare, questi metodi si basano sull'uso delle funzioni \verb|getchat_unlocked()| e \verb|putchar_unlocked()|
\begin{lstlisting}[language = cpp, frame = none]
inline static int scanInt(FILE *file = stdin) {
  int n = 0;
  int neg = 1;
  char c = getc_unlocked(file);
  if (c == '-')
    neg = -1;
  while (c < '0' || c > '9') {
    c = getc_unlocked(file);
    if (c == '-')
      neg = -1;
  }
  while (c >= '0' && c <= '9') {
    n = (n << 3) + (n << 1) + c - '0';
    c = getc_unlocked(file);
  }
  return n * neg;
}

inline static void writeInt(int v, FILE *file = stdout) {
  static char buf[14];
  int p = 0;
  if (v == 0) {
    putc_unlocked('0', file);
    return;
  }
  if (v < 0) {
    putc_unlocked('-', file);
    v = -v;
  }
  while (v) {
    buf[p++] = v % 10;
    v /= 10;
  }
  while (p--) {
    putc_unlocked(buf[p] + '0', file);
  }
}

inline static int getString(char *buf, FILE *file = stdin) {
  std::string s;
  int c = getc_unlocked(file);

  // Skip leading whitespace
  while (c != EOF && (c == ' ' || c == '\n' || c == '\t' || c == '\r'))
    c = getc_unlocked(file);

  // Read until next whitespace or EOF
  int index = 0;
  while (c != EOF && c != ' ' && c != '\n' && c != '\t' && c != '\r') {
    buf[index++] = static_cast<char>(c);
    c = getc_unlocked(file);
  }

  return index;
}

inline static void putString(const std::string &s, FILE *file = stdout) {
  for (size_t i = 0; i < s.size(); i++)
    putc_unlocked(s[i], file);
}
\end{lstlisting}
Nota che le funzioni \verb|putc_unlocked| e \verb|getc_unlocked| sono disponibili solo in sistemi operativi unix(MacOs e Linux). Si possono usare in tranquillità dato che i server che testano il nostro codice sono tutti linux, ma il codice potrebbe non compilare in locale

\subsection{Complessità}
Il punto focale delle olimpiadi di informatica è non solo quello di scrivere algoritmi funzionanti, bensì efficienti. Per questa ragione è importante fornire critesi secondo i quali valutare la velocità d'esecuzione degli algoritmi
\vskip3mm
La logica di base sta nel relazionare il \textit{numero di iterazioni} che un algoritmo deve eseguire alla \textit{dimensione dell'input}.

\subsubsection{Esempio 1}
Supponiamo di avere un algoritmo per trovare il massimo in un vettore di $ n $ elementi. L'algoritmo fa quanto segue:
\begin{itemize}
	\item Inizializza una variabile \verb|max| al primo elemento del vettore
	\item Per ogni elemento del vettore controlla se è maggiore di \verb|max|. In caso affermativo aggiorna \verb|max| all'elemento corrente
	\item Ritorna \verb|max|
\end{itemize}
\begin{algoritmo*}{Massimo vettore}
	\begin{algorithm}[H]
		\SetKwFunction{Max}{\Int max}
		\Fn{ \Max{$\Int\ v[]$}}{
			$max \gets v\left[0\right]$\;
			\For{$i = 0$ \KwTo $v.size - 1$}{
				\If{$v\left[i\right] > max$}{
					$max \gets v\left[i\right]$\;
				}
			}
			\Return{$max$}\;
		}
	\end{algorithm}
\end{algoritmo*}
In questo caso notiamo come siano necessarie $ n $ \textit{iterazioni} perchè l'algoritmo termini (dove $ n $ è la dimensione del vettore $ v $). Abbiamo quindi rapportato la dimensione dell'input alla complessità temporale dell'algoritmo
\vskip3mm
In questo caso, si dice che la complessità dell'algoritmo è $ \Theta \left(n\right) $

\subsubsection{Esempio 2}
Supponiamo di avere un algorimo che debba eseguire una moltiplicazione applicando la proprietà distributiva:
\[
	\left(a + b + c\right)\cdot \left(d + e + f\right)
\]
secondo la proprietà distributiva questo diventa:
\[
	\underbracket[0.1ex]{\left(ad + ae + af\right)}_{A}+ \underbracket[0.1ex]{\left(bd + be + bf\right)}_{B} + \underbracket[0.1ex]{\left(cd + ce + cf\right)}_{C}
\]
ritornare un vettore che contenga i coefficienti $ \left(A,B,C\right) $

\begin{algoritmo*}{Moltiplicazione distributiva}
	\begin{algorithm}[H]
		\SetKwFunction{Mul}{\Int mul}
		\Fn{ \Mul{$\Int\ v_1[]$, $\Int\ v_2[]$}}{
		$\Int\; rv$ = $\Int[0 \ldots v1.size]$\;
		\For{$i = 0$ \KwTo $v_1.size - 1$}{
			$ rv\left[i\right] = 0$\;
			\For{$j = 0$ \KwTo $v_2.size - 1$}{
				$ rv += v_1\left[i\right] \cdot  v_2\left[j\right] $\;
			}
		}
		\Return{$rv$}\;
		}
	\end{algorithm}
\end{algoritmo*}
Siccome per ogni elemento di $ v_1 $ devo scorrere interamente $ v_2 $, dovro ripetere $ v_2 * v_1 $ volte il body del ciclo.
\vskip3mm
In questo caso, se i due vettori hanno dimensione $ n $, si dice che la complessità dell'algoritmo è $ \Theta \left(n^2 \right) $

\subsubsection*{Notazione $ \Omega $, $ \Theta $, $ O $}
In generale, per valutare la complessità di un algoritmo siamo interessati a più scenari:
\begin{itemize}
	\item Nel peggiore dei casi, l'algoritmo che complessità ha? $ \rightarrow  $ notazione $ O $
	\item Nel migliore dei casi, l'algoritmo che complessità ha?$ \rightarrow  $ notazione $ \Omega  $
	\item Nel "caso medio", l'algoritmo che complessità ha?$ \rightarrow  $ notazione $ \Theta $
\end{itemize}
Nota bene: nella maggio parte dei casi siamo interessati alla coplessità nel caso pessimo $ O $ in quanto non possiamo escludere che questo si presenti nel dataset.
\vskip3mm
Per capire meglio la differenza fra caso ottimo e caso pessimo prendiamo in analisi l'algoritmo di \textit{insertion sort}:

\begin{algoritmo*}{Insertion Sort}
	\begin{algorithm}[H]
		\SetKwFunction{InsertSort}{insertionSort}
		\Fn{\Int \InsertSort{$\Int\ v[]$}}{
			\For{$i = 1$ \KwTo $v.size - 1$}{
				$\Int\ key = v[i]$\;
				$\Int\ j = i - 1$\;
				\While{$j \geq 0$  \And  $v[j] > key$}{
					$v[j + 1] = v[j]$\;
					$j = j - 1$\;
				}
				$v[j + 1] = key$\;
			}
			\Return{$v$}\;
		}
	\end{algorithm}
\end{algoritmo*}
In questo caso, dato un vettore lungo $ n $, abbiamo due casi estremi:
\begin{itemize}
	\item Il vettore è ordinato in modo crescente
	\item Il vettore è ordinato in modo decrescente
\end{itemize}
Nel primo caso l'algoritmo non entrerà mai nel ciclo while e dunque scorrerà il vettore una singola volta, originando una compessità di $ \Omega \left(n\right) $.
\vskip3mm
Nel secondo caso l'algoritmo dovrà per ogni elemento del vettore scorrere (quasi) tutto il vettore stesso, originando una complessità di $ O\left(n^2 \right) $

\subsection{Struttura problemi}
Ogni problema delle OII e delle OIS ha una struttura simile e si compone come segue:
\begin{itemize}
	\item Descrizione problema
	\item Descrizione dati di input
	\item Descrizione formato output
	\item Esempi
	\item Testcase
\end{itemize}
In particolare, il punteggio viene assegnato in base ai testcase che il nostro codice passa. Dobbiamo quindi scrivere un codice che risolva un dato problema stampando in output la soluzione. La correzione funziona come segue:
\begin{itemize}
	\item I testcase sono raggruppati in un dato numero di \textit{gruppi}
	\item Ad ogni gruppo di \textit{testcase} è assegnato un punteggio e delle assunzioni. Ad esempio, ci può essere detto che i dati in input, in un dato gruppo non superano una certa dimensione o sono strutturati in un modo particolare
	\item Se all'interno di un gruppo i testcase sono tutti passati (output corretto), allora vengono assegnati i punti, altrimenti no
\end{itemize}
Si noti che per passare un testcase non è sufficiente che l'output sia corretto, ma il tempo di esecuzione e la memoria utilizzata devono essere entro i limiti previsti, specificati nel testo del problema

\section{Programmazione dinamica}

\subsection{Donimo}
Quanti modi ho di disporre tasselle di domino in una scacchiera $ 2 \times n $?

\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Salvo in $ dp\left[i\right] $ il numero di combinazioni che ci sono per un rettangolo $ 2 \times i $
	\item Ho due opzioni:
	      \begin{itemize}
		      \item Metto 2 tessere in orizzontale, allora $ dp\left[i\right] = dp\left[i-2\right] $
		      \item Metto 1 tessera in verticale, allora $ dp\left[i\right] = dp\left[i-1\right] $
	      \end{itemize}
	\item Quindi $ dp\left[i\right] = dp\left[i-1\right] + dp\left[i-2\right] $
	\item La soluzione è $ \operatorname{Fib}\left(n\right) $
\end{itemize}
\subsection{Hateville}
Ho un vettore di prezzi. Se prendo un prezzo $ v\left[i\right] $ non posso prendere $ v\left[i-1\right] $ e $ v\left[i+1\right] $. Trova prezzo massimo

\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Salvo in $ dp\left[i\right] $ il prezzo massimo che posso ottenere con i vicini $ \le i $
	\item Ho due opzioni:
	      \begin{itemize}
		      \item Non prendo $ v\left[i\right] $, allora il prezzo è $ dp\left[i-1\right] $
		      \item Prendo $ v\left[i\right] $, allora il prezzo è $ dp\left[i-1\right] + v\left[i\right] $
	      \end{itemize}
\end{itemize}
\subsection{Zaino}\label{zaino}
Zaino ha capacità $ C $, ho $ n $ pezzi di peso $ w\left[i\right] $ e profitto $ p\left[i\right] $. Trova profitto massimo

\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Crea matrice $ n \times C $ in cui si salva $ dp\left[i\right]\left[j\right] $ il profitto massimo che si può ottenere con i pezzi $ \le i $ e capacità $ \le j $
	\item Ho due opzioni:
	      \begin{itemize}
		      \item Prendo pezzo $ \left(i,j\right) $, allora il prezzo migliore è $ dp\left[i-1\right]\left[j - w\left[i\right]\right] + p\left[i\right] $
		      \item Non lo prendo, allora il prezzo è $ dp\left[i-1\right]\left[j\right] $
	      \end{itemize}
	\item Posso ottimizzare lo spazio tenendo salvato solo due righe della matrice, la $ i $ e la $ i-1 $
\end{itemize}
\subsection{Zaino umbound}
Vedi \hyperref[zaino]{zaino}, solo che non c'è limite al numero di oggetti che uno puo prendere

\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Vettore $ dp $ in cui salvo in $ i $ il profitto massimo per uno zaino grande $ i $
	\item Per ogni peso item $ x $, il profitto massimo è $ p\left[x\right] + dp\left[i - w\left[x\right]\right] $
	\item $ dp\left[i\right] $ è il massimo fra tutti i valori trovati al punto 2
\end{itemize}
\subsection{LCS}
Date due stringhe $ U $ e $ T $, trova la \underline{sottosequenza} massimale. Una sottosequenza è una stringa che si ottiene da un'altra selezionandone solo alcuni caratteri (non necessariamente contigui, ma mantenendone l'ordine).
\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Tabella $ dp $ con $ U $ su un lato e $ T $ sull'altro. In $ dp\left[i\right]\left[j\right] $ salvo la lunghezza della $ LCS $ fra la sottostringa $ U\left[0,i\right] $ e $ T\left[0, j\right] $
	\item Ho due opzioni:
	      \begin{itemize}
		      \item $ U\left[i\right] = T[j] $, allora $ dp\left[i\right]\left[j\right] = dp\left[i-1\right]\left[j-1\right] +1 $ (aggiungo un carattere alla LCS più corta di 1)
		      \item $  U\left[i\right] \neq T[j] $  allora $ dp\left[i\right]\left[j\right] = \operatorname{max}\left(dp\left[i-1\right]\left[j\right], dp\left[i\right]\left[j-1\right]\right) $. Vedi immagine
	      \end{itemize}
\end{itemize}

\begin{center}
	\begin{tikzpicture}[scale=0.7]
		\draw [fill=mutedgreen!50](6, 0)rectangle ++ (2,1);
		\draw (0,0)grid(8,1);

		\draw [fill=mutedred!50](6, -3)rectangle ++ (4,1);
		\draw (0,-3)grid(10,-2);

		\begin{scope}[shift={(0.5,0.5)}]
			\node at (-1, 0) {$ U $};

			\node (1) at (0,0)  {a};
			\node (2) at (1,0)  {u};
			\node (3) at (2,0)  {t};
			\node (4) at (3,0)  {s};
			\node (5) at (4,0)  {s};
			\node (6) at (5,0)  {g};
			\node (7) at (6,0)  {n};
			\node (18) at (7,0)  {k};
			\node [anchor = south] at (7,0.5)  {$ i $};

			\node at (-1, -3) {$ V $};

			\node (8)  at (0,-3)  {w};
			\node (9)  at (1,-3)  {a};
			\node (10) at (2,-3)  {t};
			\node (11) at (3,-3)  {f};
			\node (12) at (4,-3)  {x};
			\node (13) at (5,-3)  {m};
			\node (14) at (6,-3)  {g};
			\node (15) at (7,-3)  {o};
			\node (16) at (8,-3)  {i};
			\node (17) at (9,-3)  {m};
			\node [anchor = south] at (6,-2.5)  {$ j $};
			% \node (15) at (7,-3)  {o};
			% \node (16) at (8,-3)  {i};

		\end{scope}

		\node (lcs)[circle] at (2,-1) {lcs};

		\draw (lcs)edge(1.south) edge (3.south) edge(6.south);
		\draw (lcs)edge(9.north) edge (10.north) edge(14.north);

	\end{tikzpicture}
\end{center}

Per migliorare la soluzione, se i caratteri sono diversi, devo aggiungere un carattere che sia nell'insieme dei caratteri dopo l'ultimo carattere comune. Quindi ho che
\begin{itemize}
	\item A $ T $, devo aggiungere un carattere che appartiene all'insieme rosso
	\item A $ U $, devo aggiungere un carattere che appartiene all'insieme verde
\end{itemize}
Chiaramente la cosa è asimmetrica, per questo devo controllare $ dp\left[i-1\right]\left[j\right] $ e $ dp\left[i\right]\left[j-1\right] $
\vskip3mm
\sfblue{Dimostrazione formale}: dobbiamo dimostrare che date due parole $ U \left(u_1,\ldots ,u_i\right) $ e $ V\left(v_1 , \ldots v_j\right) $ e $ X \left(x_1 , \ldots x_k\right) $ allora
\begin{itemize}
	\item Se $ u_i = v_j $  allora
	      \begin{gather*}
		      u_i = v_j = x_k \\
		      X\left(K-1\right) \in \mathcal{LCS}\left(U\left(i-1\right), V\left(j-1\right)\right)
	      \end{gather*}
	\item Se $ u_i \neq v_j $ e $ x_k \neq  u_i $ allora
	      \[
		      X \in \mathcal{LCS}\left(U\left(i-1\right), V \right)
	      \]
	\item Se $ u_i \neq v_j $ e $ x_k \neq  v_j $ allora
	      \[
		      X \in \mathcal{LCS}\left(U, V\left(j-1\right) \right)
	      \]
\end{itemize}

\begin{minipage}[t]{0.48\textwidth}
	\begin{center}
		\begin{tikzpicture}[scale=0.7]
			\draw (0,0)grid(8,1);
			\draw [fill=mutedgreen!50](7, 0)rectangle ++ (1,1);

			\draw (0,-3)grid(7,-2);
			\draw [fill=mutedred!50](6, -3)rectangle ++ (1,1);

			\begin{scope}[shift={(0.5,0.5)}]
				\node at (-1, 0) {$ U $};

				\node (1) at (0,0)  {a};
				\node (2) at (1,0)  {u};
				\node (3) at (2,0)  {t};
				\node (4) at (3,0)  {s};
				\node (5) at (4,0)  {s};
				\node (6) at (5,0)  {g};
				\node (7) at (6,0)  {n};
				\node (17) at (7,0)  {k};
				\node [anchor = south] at (7,0.5)  {$ i $};

				\node at (-1, -3) {$ V $};

				\node (8)  at (0,-3)  {w};
				\node (9)  at (1,-3)  {a};
				\node (10) at (2,-3)  {t};
				\node (11) at (3,-3)  {f};
				\node (12) at (4,-3)  {x};
				\node (13) at (5,-3)  {m};
				\node (14) at (6,-3)  {g};
				\node [anchor = south] at (6,-2.5)  {$ j $};
				% \node (15) at (7,-3)  {o};
				% \node (16) at (8,-3)  {i};

			\end{scope}

			\node (lcs)[circle] at (2,-1) {lcs};

			\draw (lcs)edge(1.south) edge (3.south) edge(6.south);
			\draw (lcs)edge(9.north) edge (10.north) edge(14.north);

		\end{tikzpicture}
	\end{center}
\end{minipage}
%
\begin{minipage}[t]{0.48\textwidth}
	\begin{center}
		\begin{tikzpicture}[scale=0.7]

			\draw (0,0)grid(6,1);
			\draw [fill=mutedblue!50](5, 0)rectangle(6,1);

			\draw (0,-3)grid(7,-2);
			\draw [fill=mutedblue!50](6, -3)rectangle(7,-2);

			\begin{scope}[shift={(0.5,0.5)}]
				\node at (-1, 0) {$ U $};

				\node (1) at (0,0)  {a};
				\node (2) at (1,0)  {u};
				\node (3) at (2,0)  {t};
				\node (4) at (3,0)  {s};
				\node (5) at (4,0)  {s};
				\node (6) at (5,0)  {g};
				\node [anchor = south] at (5,0.5)  {$ i $};

				\node at (-1, -3) {$ V $};

				\node (8)  at (0,-3)  {w};
				\node (9)  at (1,-3)  {a};
				\node (10) at (2,-3)  {t};
				\node (11) at (3,-3)  {f};
				\node (12) at (4,-3)  {x};
				\node (13) at (5,-3)  {m};
				\node (14) at (6,-3)  {g};
				\node [anchor = south] at (6,-2.5)  {$ j $};
				% \node (15) at (7,-3)  {o};
				% \node (16) at (8,-3)  {i};

			\end{scope}

			\node (lcs)[circle] at (2,-1) {lcs};

			\draw (lcs)edge(1.south) edge (3.south) edge(6.south);
			\draw (lcs)edge(9.north) edge (10.north) edge(14.north);

		\end{tikzpicture}
	\end{center}
\end{minipage}


\subsection{Occorrenza k approssimata}
Data una stringa $ t $ e una $ p $, diciamo che la distanza $ k $ di $ p $ da $ t $ è il numero \underline{minimo} di \textit{inserimenti, eliminazioni e scambi} che dobbiamo fare in $ t $ per far si che $ t == p $.
\[
	t = \text{ "scempio" }, \quad p = \text{ esempio } \rightarrow k = 2
\]
ad esempio, scambiando la "s" e "c" di \textit{scempio} in "e" ed "s" rispettivamente
\vskip3mm
Il problma sta nel trovare in un testo $ t $, la distanza minima di un pattern $ p $ da una sua qualsiasi sottostringa.
\vskip3mm
Ciò equivale a trovare quanti inserimenti, rimozioni e scambi devo fare \underline{nel testo} per far si che il pattern diventi una sua sottostringa
\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Inizializza matrice che ha $ p $ in verticale e $ t $ in orizzontale
	\item In $ dp\left[i\right]\left[j\right] $ si salva \textit{il minor valore di k per far si che $ p\left[0, i\right] $ sia sottostringa di $ t\left[0, j\right] $ che finisca in $ j $}
	\item Se $ p\left[i\right] == t\left[j\right] $ allora non serviranno altre mosse per riportare la soluzione di $ dp\left[i-1\right]\left[j-1\right] $ alla soluzione corrente
	\item Se $ p\left[i\right] \neq  t\left[j\right] $  allora posso fare 3 cose:
\end{itemize}

\begin{center}
	% \includegraphics{images/K approx.pdf }
	\begin{tikzpicture}[scale=0.6]

		\begin{scope}
			\draw [fill=mutedred!50](1,4)rectangle(4,3);
			\draw [fill=mutedgreen!50](0,0)rectangle(1,3);

			\draw (0,0)grid(7,4);

			\draw [thick, mutedblue](0,0)rectangle(1,3);
			\draw [thick, mutedblue](1,4)rectangle(3,3);

			\begin{scope}[shift={(0.5,0.5)}]
				\node at (0,2){b};
				\node at (0,1){a};
				\node at (0,0){b};

				\node at (1,3){a};
				\node at (2,3){b};
				\node at (3,3){a};
				\node at (4,3){b};
				\node at (5,3){a};
				\node at (6,3){g};

				\node at (3,0){?};
				\node at (2,0){$ \rightarrow $};

				% \node at[3,0] {Fai coincidere bab con ab e poi elimina a};
				\node at (3,-1) {+1};
				\node [align = center] at (3,-2) {Fai coincidere bab con ab\\ e poi elimina a};
			\end{scope}
		\end{scope}

		\begin{scope}[shift={(8,0)}]
			\draw [fill=mutedred!50](1,4)rectangle(4,3);
			\draw [fill=mutedgreen!50](0,0)rectangle(1,3);

			\draw (0,0)grid(7,4);

			\draw [thick, mutedblue](0,1)rectangle(1,3);
			\draw [thick, mutedblue](1,4)rectangle(4,3);

			\begin{scope}[shift={(0.5,0.5)}]
				\node at (0,2){b};
				\node at (0,1){a};
				\node at (0,0){b};

				\node at (1,3){a};
				\node at (2,3){b};
				\node at (3,3){a};
				\node at (4,3){b};
				\node at (5,3){a};
				\node at (6,3){g};

				\node at (3,0){?};
				\node at (3,1){$ \downarrow $};

				\node at (3,-1) {+1};
				\node [align = center] at (3,-2) {Fai coincidere ba con aba\\ e poi aggiungi b};
			\end{scope}
		\end{scope}

		\begin{scope}[shift={(16,0)}]
			\draw [fill=mutedred!50](1,4)rectangle(4,3);
			\draw [fill=mutedgreen!50](0,0)rectangle(1,3);

			\draw (0,0)grid(7,4);

			\draw [thick, mutedblue](0,1)rectangle(1,3);
			\draw [thick, mutedblue](1,4)rectangle(3,3);

			\begin{scope}[shift={(0.5,0.5)}]
				\node at (0,2){b};
				\node at (0,1){a};
				\node at (0,0){b};

				\node at (1,3){a};
				\node at (2,3){b};
				\node at (3,3){a};
				\node at (4,3){b};
				\node at (5,3){a};
				\node at (6,3){g};

				\node at (3,0){?};
				\node at (2,1){$ \searrow $};

				\node at (3,-1) {+1};
				\node [align = center] at (3,-2) {Fai coincidere ba con ab\\ e poi cambia a in b};
			\end{scope}
		\end{scope}

	\end{tikzpicture}
\end{center}

La soluzione migliore è data dal minimo valore nell'ultima riga della tabella
\vskip3mm
Nota che la prima riga e la prima colonna vanno riempite rispettivamente con $ \left[0,\ldots , 0\right] $ e $ \left[1,2,\ldots , n-1, n\right] $. Questo ha senso in quanto:
\begin{itemize}
	\item Per far si che il pattern vuoto sia sottostringa di $ t $ non serve alsona mossa ($ \left[0,\ldots ,0\right] $)
	\item Per far sic che un pattern di lunghezza $ k $ sia sottostringa del testo vuoto è necessario aggiungere i $ k $ caratteri del pattern ($ \left[1,2,\ldots , n-1, n\right] $)
\end{itemize}
\subsection{Prodotto di catena di matrici}
Si vuole fare il prodotto matriciale tra $ \left[A_1, A_2,  \ldots, A_{n-1}, A_n \right] $. Il prodotto matriciale gode di proprietà associativa. Si trovi la parentizzazione che riduce al minimo il numero di moltiplicazioni scalari totali da compiere
\vskip3mm
Ad esempio, avendo $ \left[A, B, C, D\right] $, posso parentizzare come segue:
\[
	\left[\left(A \cdot B\right) \cdot \left(C \cdot D\right)\right], \quad \left[A \cdot \left(B \cdot C \right) \cdot D\right], \quad \left[A \cdot \left(B \cdot \left(C  \cdot D\right)\right)\right]
\]
e cosi via. Questo funziona in quanto per moltiplicare delle matrici bisogna assicurarsi che queste siano compatibili. Il numero di colonne della prima deve essere uguale al numero di righe della seconda. Ad esempio, indicando con $ \left[\text{righe}, \text{colonne}\right] $ una matrice, una serie che può essere moltiplicata è la seguente:
\[
	\left[4,5\right] \cdot \left[5, 2\right] \cdot \left[2, 10\right]  \cdot \left[10, 7\right] \rightarrow \left[4,5,2,10,7\right]
\]
\vskip3mm
Nota che la dimensione di ogni matrice può essere salvata in un vettore $ c $ in cui $ c_i $ contiene il numero di colonne della matrice $ i $, che corrisponde al numero di righe della matrice $ i+1 $. Quindi il numero di moltiplicazioni necessarie per eseguire $ A_i \times A_j $ sarà:
\[
	c_i \cdot (\cdot c_{i-1} \cdot c_j)
\]
\begin{itemize}
	\item $ c_i $: numero di moltiplicazioni per calcolare una cella
	\item $ (\cdot c_{i-1} \cdot c_j) $: dimensione della matrice risultante
\end{itemize}
\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Creo matrice \verb|dp| come seguen:
	      \begin{center}
		      \begin{tabular}{|c|c|c|c|c|c|c|}
			      \hline
			        & 1 & 2 & 3 & 4 & 5 & 6 \\
			      \hline
			      1 & 0 &   &   &   &   &   \\
			      \hline
			      2 & - & 0 &   &   &   &   \\
			      \hline
			      3 & - & - & 0 &   &   &   \\
			      \hline
			      4 & - & - & - & 0 &   &   \\
			      \hline
			      5 & - & - & - & - & 0 &   \\
			      \hline
			      6 & - & - & - & - & - & 0 \\
			      \hline
		      \end{tabular}
	      \end{center}
	\item In \verb|dp[i][j]| salvo il minor numero di moltiplicazioni necessarie per moltiplicare le matrici fra \verb|i|  e \verb|j|
	\item Costruisco matrice scorrento in diagonale a partire dalla diagonale più vicina alla diagonale principale. Il numero minore è dato dal numero minore date due parentizzazioni, ad esempio se ho
	      \[
		      \left[A_3,A_4,A_5, A_6\right]
	      \]
	      dovro tentare con
	      \[
		      \left[\left(A_3\right) \cdot  \left(A_4, A_5, A_6\right)\right], \quad \left[\left(A_3, A_4\right) \cdot  \left(A_5, A_6\right)\right], \quad \left[\left(A_3, A_4, A_5\right) \cdot  \left(A_6\right)\right]
	      \]
	\item Il risultato finale si trova in \verb|dp[1][n]|, dove \verb|n| è il numero di matrici
	\item Per ricostruire la parentizzazione, posso salvarmi in una tabella \verb|last[i][j]| l'indice a cui ho "spezzato la parentizzazione". Poi posso ricostruirla ricorsivamente come segue:
\end{itemize}

\begin{algoritmo}{Find minimum parenthesization}
	\begin{algorithm}[H]
		\caption{Print optimal parenthesization}
		\SetKwFunction{FPrintPar}{printPar}
		\Fn{\FPrintPar{$\text{int}\ last[][],\ \text{int}\ i,\ \text{int}\ j$}}{
		\If{$i == j$}{
		\Print "A["; \Print $i$; \Print "]"\;
		}
		\Else{
			\Print "("\;
			\FPrintPar{$last,\ i,\ last[i][j]$}\;
			\Print "."\;
			\FPrintPar{$last,\ last[i][j]+1,\ j$}\;
			\Print ")"\;
		}
		}
	\end{algorithm}
\end{algoritmo}
\subsection{Intervalli pesati}\label{intervalli pesati}
Vengono dati $ n $ intervalli aperti $ \left[a_1, b_1\right[, \left[a_2, b_2\right[ , \ldots  \left[a_n, b_n\right[ $. Ogni intervalli ha un valore $ w_i $. Trovare il valore massimo che si può ottenere selezionando intervalli \underline{non sovrapposti}.

\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Ordina intervalli per \underline{tempo di fine}
	\item Definisco la funzione \verb|pred(i)|, che ritorna il \textit{predecessore} di un intervallo, ossia il primo intervallo che ha tempo di fine minore del tempo di inizio di $ i $
	\item Creo vettore \verb|dp| che salva in \verb|i| \underline{il valore massimo ottenibile con gli intervalli fino ad {\ttfamily i}} compreso
	\item Itero su intervalli. Per ciascun intervallo \verb|i| posso:
	      \begin{itemize}
		      \item Selezionarlo: in questo il valore massimo ottenibile è dato da {\ttfamily dp[pred(i)] + $ \text{w}_{\text{i}} $} a
		      \item \underline{Non} selezionarlo: in questo caso il valore massimo è uguale al precedente {\ttfamily dp[i-1]}
	      \end{itemize}
\end{itemize}
Complessità: $ O\left(n \log n\right) $

\section{Problemi sito oii consigliati}
\subsection{Figonacci {(\protect\texttt{\href{https://training.olinfo.it/task/ois_figonacci}{figonacci}})}}
\begin{center}
	\begin{tabularx}{\textwidth}{X r}
		\toprule
		Problema sito OII  & \url{https://training.olinfo.it/task/ois_figonacci}                       \\
		Soluzione proposta & \ttfamily\href{run:./files/esercizi/figonacci/}{files/esercizi/figonacci} \\
		\bottomrule
	\end{tabularx}
\end{center}

\subsection{Discesa massima {(\protect{\texttt{\href{https://training.olinfo.it/task/discesa}{discesa}}})}}
\begin{center}
	\begin{tabularx}{\textwidth}{X r}
		\toprule
		Problema sito OII  & \url{https://training.olinfo.it/task/discesa}                         \\
		Soluzione proposta & \ttfamily\href{run:./files/esercizi/discesa/}{files/esercizi/discesa} \\
		\bottomrule
	\end{tabularx}
\end{center}

\subsection{Police 3 {(\protect{\texttt{\href{https://training.olinfo.it/task/ois_police3}{\ttfamily police3}}})}}
\begin{center}
	\begin{tabularx}{\textwidth}{X r}
		\toprule
		Problema sito OII  & \url{https://training.olinfo.it/task/ois_police3}                     \\
		Soluzione proposta & \ttfamily\href{run:./files/esercizi/discesa/}{files/esercizi/police3} \\
		\bottomrule
	\end{tabularx}
\end{center}


\begin{itemize}
	\item Police 3 (\protect{\texttt{\href{https://training.olinfo.it/task/ois_police3}{\ttfamily police3}}})
	\item Piano degli studi (\protect{\texttt{\href{https://training.olinfo.it/task/ois_pianostudi}{pianostudi}}})
	\item Police 4 (\protect{\texttt{\href{https://training.olinfo.it/task/ois_police4}{\ttfamily police4}}})
	\item Spiedini di frutta (\protect{\texttt{\href{https://training.olinfo.it/task/oii_spiedini}{spiedini}}})
	\item K-step ancestor (\protect{\texttt{\href{https://training.olinfo.it/task/ois_treeancestor}{treeancestor}}})
	\item Taglialegna (\protect{\texttt{\href{https://training.olinfo.it/task/oii_taglialegna}{taglialegna}}})
\end{itemize}



\end{document}
