%&../.preamble

\externalize{../.preamble}

\usepackage{pifont}
\usepackage{makecell}
\usepackage{contour}
% \usepackage{amssymb}        % gives \bigstar
\title{Pelstra di algoritmi}
\author{Marini Mattia}
\date{20 ottobre 2025}

\begin{document}
\maketitle
\license{Palestra di algoritmi}
\tableofcontents
\newpage

\section{Introduzione}
Qui di seguito sono raccolte nozioni di base per affrontare ogni probrema relativo alle \textit{OII}

\subsection{Basi cpp}
In ogni problema è necessario effettuare input/output su file\footnote{In realtà a volte è sufficiente implementare il body di una funzione oppure la parte relativa all'output viene fornita}. Ci sono diversi modi per eseguire ciò.
\subsubsection{Input metodo 1 (consigliato)}
Vedi file \href{run:./files/teoria/input1/}{input1.cpp}
\vskip3mm
L'idea è di creare un oggeto \verb|ifstream| e \verb|ofstream| che poi potremmo utilizzare in maniera totalmente analoga a, rispettivamente, \verb|cin| e \verb|cout|
\begin{lstlisting}[language = cpp, frame = none]
std::ifstream in("input.txt");
in >> a >> b;

std::ifstream out("output.txt");
out << a << b
\end{lstlisting}
Esiste un trucco per velocizzare notevolmente la velocità di input/output utilizzando questo metodo. In particolare, è sufficiente appendere le seguenti righe prima di scrivere o leggere su files:
\begin{lstlisting}[language = cpp, frame = none]
ios_base::sync_with_stdio(false); 
cin.tie(NULL);
\end{lstlisting}
Tuttavia se il problema sfora i limiti di tempo, con ogni probabilità è la soluzione a non essere corretta, non le operazioni di input/output. Queste righe possono essere utili per scalare la classifica sui siti di allenamento, non per altro

\subsubsection{Input metodo 2}
Vedi file \href{run:./files/teoria/input/}{input2.cpp}
\vskip3mm
Questo metodo è più "vecchio" e meno consigliato. L'idea è di utilizzare le funzioni \verb|freopen| per reindirizzare lo standard input/output su file:
\begin{lstlisting}[language = cpp, frame = none]
FILE *in = fopen("input.txt", "r");
fscanf(in, "%d %d", &a, &b);

FILE *out = fopen("output.txt", "w");
fprintf(out, "%d %d\n", a, b);
\end{lstlisting}
dove le funzioni \verb|fprintf| e \verb|fscanf| prendono come argomenti:
\begin{itemize}
	\item Il puntatore ad un file \verb|FILE *|
	\item Una stringa \verb|format|, contenente una serie di specificatori, preceduti da "{\ttfamily \%}"
	      \begin{itemize}
		      \item \verb|d|: decimal, numero intero
		      \item \verb|f|: float
		      \item \verb|s|: stringa c-style, in particolare \verb|char *|
	      \end{itemize}
	\item Una serie variabili che corrispondono a quanto indicato in \verb|format|. Nel caso di \verb|scanf| è richiesto l'indirizzo di memoria di queset
\end{itemize}
\subsubsection{Ultra fast io}
Ci sono infine alcuni metodi per velocizzare l'input al massimo, utili per sprepere la perfomance al massimo, per arrivare nei primi in classifica. In particolare, questi metodi si basano sull'uso delle funzioni \verb|getchat_unlocked()| e \verb|putchar_unlocked()|
\begin{lstlisting}[language = cpp, frame = none]
inline static int scanInt(FILE *file = stdin) {
  int n = 0;
  int neg = 1;
  char c = getc_unlocked(file);
  if (c == '-')
    neg = -1;
  while (c < '0' || c > '9') {
    c = getc_unlocked(file);
    if (c == '-')
      neg = -1;
  }
  while (c >= '0' && c <= '9') {
    n = (n << 3) + (n << 1) + c - '0';
    c = getc_unlocked(file);
  }
  return n * neg;
}

inline static void writeInt(int v, FILE *file = stdout) {
  static char buf[14];
  int p = 0;
  if (v == 0) {
    putc_unlocked('0', file);
    return;
  }
  if (v < 0) {
    putc_unlocked('-', file);
    v = -v;
  }
  while (v) {
    buf[p++] = v % 10;
    v /= 10;
  }
  while (p--) {
    putc_unlocked(buf[p] + '0', file);
  }
}

inline static int getString(char *buf, FILE *file = stdin) {
  std::string s;
  int c = getc_unlocked(file);

  // Skip leading whitespace
  while (c != EOF && (c == ' ' || c == '\n' || c == '\t' || c == '\r'))
    c = getc_unlocked(file);

  // Read until next whitespace or EOF
  int index = 0;
  while (c != EOF && c != ' ' && c != '\n' && c != '\t' && c != '\r') {
    buf[index++] = static_cast<char>(c);
    c = getc_unlocked(file);
  }

  return index;
}

inline static void putString(const std::string &s, FILE *file = stdout) {
  for (size_t i = 0; i < s.size(); i++)
    putc_unlocked(s[i], file);
}
\end{lstlisting}
Nota che le funzioni \verb|putc_unlocked| e \verb|getc_unlocked| sono disponibili solo in sistemi operativi unix(MacOs e Linux). Si possono usare in tranquillità dato che i server che testano il nostro codice sono tutti linux, ma il codice potrebbe non compilare in locale

\subsection{Complessità}
Il punto focale delle olimpiadi di informatica è non solo quello di scrivere algoritmi funzionanti, bensì efficienti. Per questa ragione è importante fornire critesi secondo i quali valutare la velocità d'esecuzione degli algoritmi
\vskip3mm
La logica di base sta nel relazionare il \textit{numero di iterazioni} che un algoritmo deve eseguire alla \textit{dimensione dell'input}.

\subsubsection{Esempio 1}
Supponiamo di avere un algoritmo per trovare il massimo in un vettore di $ n $ elementi. L'algoritmo fa quanto segue:
\begin{itemize}
	\item Inizializza una variabile \verb|max| al primo elemento del vettore
	\item Per ogni elemento del vettore controlla se è maggiore di \verb|max|. In caso affermativo aggiorna \verb|max| all'elemento corrente
	\item Ritorna \verb|max|
\end{itemize}
\begin{algoritmo*}{Massimo vettore}
	\begin{algorithm}[H]
		\SetKwFunction{Max}{\Int max}
		\Fn{ \Max{$\Int\ v[]$}}{
			$max \gets v\left[0\right]$\;
			\For{$i = 0$ \KwTo $v.size - 1$}{
				\If{$v\left[i\right] > max$}{
					$max \gets v\left[i\right]$\;
				}
			}
			\Return{$max$}\;
		}
	\end{algorithm}
\end{algoritmo*}
In questo caso notiamo come siano necessarie $ n $ \textit{iterazioni} perchè l'algoritmo termini (dove $ n $ è la dimensione del vettore $ v $). Abbiamo quindi rapportato la dimensione dell'input alla complessità temporale dell'algoritmo
\vskip3mm
In questo caso, si dice che la complessità dell'algoritmo è $ \Theta \left(n\right) $

\subsubsection{Esempio 2}
Supponiamo di avere un algorimo che debba eseguire una moltiplicazione applicando la proprietà distributiva:
\[
	\left(a + b + c\right)\cdot \left(d + e + f\right)
\]
secondo la proprietà distributiva questo diventa:
\[
	\underbracket[0.1ex]{\left(ad + ae + af\right)}_{A}+ \underbracket[0.1ex]{\left(bd + be + bf\right)}_{B} + \underbracket[0.1ex]{\left(cd + ce + cf\right)}_{C}
\]
ritornare un vettore che contenga i coefficienti $ \left(A,B,C\right) $

\begin{algoritmo*}{Moltiplicazione distributiva}
	\begin{algorithm}[H]
		\SetKwFunction{Mul}{\Int mul}
		\Fn{ \Mul{$\Int\ v_1[]$, $\Int\ v_2[]$}}{
		$\Int\; rv$ = $\Int[0 \ldots v1.size]$\;
		\For{$i = 0$ \KwTo $v_1.size - 1$}{
			$ rv\left[i\right] = 0$\;
			\For{$j = 0$ \KwTo $v_2.size - 1$}{
				$ rv += v_1\left[i\right] \cdot  v_2\left[j\right] $\;
			}
		}
		\Return{$rv$}\;
		}
	\end{algorithm}
\end{algoritmo*}
Siccome per ogni elemento di $ v_1 $ devo scorrere interamente $ v_2 $, dovro ripetere $ v_2 * v_1 $ volte il body del ciclo.
\vskip3mm
In questo caso, se i due vettori hanno dimensione $ n $, si dice che la complessità dell'algoritmo è $ \Theta \left(n^2 \right) $

\subsubsection*{Notazione $ \Omega $, $ \Theta $, $ O $}
In generale, per valutare la complessità di un algoritmo siamo interessati a più scenari:
\begin{itemize}
	\item Nel peggiore dei casi, l'algoritmo che complessità ha? $ \rightarrow  $ notazione $ O $
	\item Nel migliore dei casi, l'algoritmo che complessità ha?$ \rightarrow  $ notazione $ \Omega  $
	\item Nel "caso medio", l'algoritmo che complessità ha?$ \rightarrow  $ notazione $ \Theta $
\end{itemize}
Nota bene: nella maggio parte dei casi siamo interessati alla coplessità nel caso pessimo $ O $ in quanto non possiamo escludere che questo si presenti nel dataset.
\vskip3mm
Per capire meglio la differenza fra caso ottimo e caso pessimo prendiamo in analisi l'algoritmo di \textit{insertion sort}:

\begin{algoritmo*}{Insertion Sort}
	\begin{algorithm}[H]
		\SetKwFunction{InsertSort}{insertionSort}
		\Fn{\Int \InsertSort{$\Int\ v[]$}}{
			\For{$i = 1$ \KwTo $v.size - 1$}{
				$\Int\ key = v[i]$\;
				$\Int\ j = i - 1$\;
				\While{$j \geq 0$  \And  $v[j] > key$}{
					$v[j + 1] = v[j]$\;
					$j = j - 1$\;
				}
				$v[j + 1] = key$\;
			}
			\Return{$v$}\;
		}
	\end{algorithm}
\end{algoritmo*}
In questo caso, dato un vettore lungo $ n $, abbiamo due casi estremi:
\begin{itemize}
	\item Il vettore è ordinato in modo crescente
	\item Il vettore è ordinato in modo decrescente
\end{itemize}
Nel primo caso l'algoritmo non entrerà mai nel ciclo while e dunque scorrerà il vettore una singola volta, originando una compessità di $ \Omega \left(n\right) $.
\vskip3mm
Nel secondo caso l'algoritmo dovrà per ogni elemento del vettore scorrere (quasi) tutto il vettore stesso, originando una complessità di $ O\left(n^2 \right) $

\subsection{Struttura problemi}
Ogni problema delle OII e delle OIS ha una struttura simile e si compone come segue:
\begin{itemize}
	\item Descrizione problema
	\item Descrizione dati di input
	\item Descrizione formato output
	\item Esempi
	\item Testcase
\end{itemize}
In particolare, il punteggio viene assegnato in base ai testcase che il nostro codice passa. Dobbiamo quindi scrivere un codice che risolva un dato problema stampando in output la soluzione. La correzione funziona come segue:
\begin{itemize}
	\item I testcase sono raggruppati in un dato numero di \textit{gruppi}
	\item Ad ogni gruppo di \textit{testcase} è assegnato un punteggio e delle assunzioni. Ad esempio, ci può essere detto che i dati in input, in un dato gruppo non superano una certa dimensione o sono strutturati in un modo particolare
	\item Se all'interno di un gruppo i testcase sono tutti passati (output corretto), allora vengono assegnati i punti, altrimenti no
\end{itemize}
Si noti che per passare un testcase non è sufficiente che l'output sia corretto, ma il tempo di esecuzione e la memoria utilizzata devono essere entro i limiti previsti, specificati nel testo del problema

\section{Programmazione dinamica}

\subsection{Donimo}
Quanti modi ho di disporre tasselle di domino in una scacchiera $ 2 \times n $?

\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Salvo in $ dp\left[i\right] $ il numero di combinazioni che ci sono per un rettangolo $ 2 \times i $
	\item Ho due opzioni:
	      \begin{itemize}
		      \item Metto 2 tessere in orizzontale, allora $ dp\left[i\right] = dp\left[i-2\right] $
		      \item Metto 1 tessera in verticale, allora $ dp\left[i\right] = dp\left[i-1\right] $
	      \end{itemize}
	\item Quindi $ dp\left[i\right] = dp\left[i-1\right] + dp\left[i-2\right] $
	\item La soluzione è $ \operatorname{Fib}\left(n\right) $
\end{itemize}
\subsection{Hateville}
Ho un vettore di prezzi. Se prendo un prezzo $ v\left[i\right] $ non posso prendere $ v\left[i-1\right] $ e $ v\left[i+1\right] $. Trova prezzo massimo

\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Salvo in $ dp\left[i\right] $ il prezzo massimo che posso ottenere con i vicini $ \le i $
	\item Ho due opzioni:
	      \begin{itemize}
		      \item Non prendo $ v\left[i\right] $, allora il prezzo è $ dp\left[i-1\right] $
		      \item Prendo $ v\left[i\right] $, allora il prezzo è $ dp\left[i-1\right] + v\left[i\right] $
	      \end{itemize}
\end{itemize}
\subsection{Zaino}\label{zaino}
Zaino ha capacità $ C $, ho $ n $ pezzi di peso $ w\left[i\right] $ e profitto $ p\left[i\right] $. Trova profitto massimo

\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Crea matrice $ n \times C $ in cui si salva $ dp\left[i\right]\left[j\right] $ il profitto massimo che si può ottenere con i pezzi $ \le i $ e capacità $ \le j $
	\item Ho due opzioni:
	      \begin{itemize}
		      \item Prendo pezzo $ \left(i,j\right) $, allora il prezzo migliore è $ dp\left[i-1\right]\left[j - w\left[i\right]\right] + p\left[i\right] $
		      \item Non lo prendo, allora il prezzo è $ dp\left[i-1\right]\left[j\right] $
	      \end{itemize}
	\item Posso ottimizzare lo spazio tenendo salvato solo due righe della matrice, la $ i $ e la $ i-1 $
\end{itemize}
\subsection{Zaino umbound}
Vedi \hyperref[zaino]{zaino}, solo che non c'è limite al numero di oggetti che uno puo prendere

\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Vettore $ dp $ in cui salvo in $ i $ il profitto massimo per uno zaino grande $ i $
	\item Per ogni peso item $ x $, il profitto massimo è $ p\left[x\right] + dp\left[i - w\left[x\right]\right] $
	\item $ dp\left[i\right] $ è il massimo fra tutti i valori trovati al punto 2
\end{itemize}
\subsection{LCS}
Date due stringhe $ U $ e $ T $, trova la \underline{sottosequenza} massimale. Una sottosequenza è una stringa che si ottiene da un'altra selezionandone solo alcuni caratteri (non necessariamente contigui, ma mantenendone l'ordine).
\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Tabella $ dp $ con $ U $ su un lato e $ T $ sull'altro. In $ dp\left[i\right]\left[j\right] $ salvo la lunghezza della $ LCS $ fra la sottostringa $ U\left[0,i\right] $ e $ T\left[0, j\right] $
	\item Ho due opzioni:
	      \begin{itemize}
		      \item $ U\left[i\right] = T[j] $, allora $ dp\left[i\right]\left[j\right] = dp\left[i-1\right]\left[j-1\right] +1 $ (aggiungo un carattere alla LCS più corta di 1)
		      \item $  U\left[i\right] \neq T[j] $  allora $ dp\left[i\right]\left[j\right] = \operatorname{max}\left(dp\left[i-1\right]\left[j\right], dp\left[i\right]\left[j-1\right]\right) $. Vedi immagine
	      \end{itemize}
\end{itemize}

\begin{center}
	\begin{tikzpicture}[scale=0.7]
		\draw [fill=mutedgreen!50](6, 0)rectangle ++ (2,1);
		\draw (0,0)grid(8,1);

		\draw [fill=mutedred!50](6, -3)rectangle ++ (4,1);
		\draw (0,-3)grid(10,-2);

		\begin{scope}[shift={(0.5,0.5)}]
			\node at (-1, 0) {$ U $};

			\node (1) at (0,0)  {a};
			\node (2) at (1,0)  {u};
			\node (3) at (2,0)  {t};
			\node (4) at (3,0)  {s};
			\node (5) at (4,0)  {s};
			\node (6) at (5,0)  {g};
			\node (7) at (6,0)  {n};
			\node (18) at (7,0)  {k};
			\node [anchor = south] at (7,0.5)  {$ i $};

			\node at (-1, -3) {$ V $};

			\node (8)  at (0,-3)  {w};
			\node (9)  at (1,-3)  {a};
			\node (10) at (2,-3)  {t};
			\node (11) at (3,-3)  {f};
			\node (12) at (4,-3)  {x};
			\node (13) at (5,-3)  {m};
			\node (14) at (6,-3)  {g};
			\node (15) at (7,-3)  {o};
			\node (16) at (8,-3)  {i};
			\node (17) at (9,-3)  {m};
			\node [anchor = south] at (6,-2.5)  {$ j $};
			% \node (15) at (7,-3)  {o};
			% \node (16) at (8,-3)  {i};

		\end{scope}

		\node (lcs)[circle] at (2,-1) {lcs};

		\draw (lcs)edge(1.south) edge (3.south) edge(6.south);
		\draw (lcs)edge(9.north) edge (10.north) edge(14.north);

	\end{tikzpicture}
\end{center}

Per migliorare la soluzione, se i caratteri sono diversi, devo aggiungere un carattere che sia nell'insieme dei caratteri dopo l'ultimo carattere comune. Quindi ho che
\begin{itemize}
	\item A $ T $, devo aggiungere un carattere che appartiene all'insieme rosso
	\item A $ U $, devo aggiungere un carattere che appartiene all'insieme verde
\end{itemize}
Chiaramente la cosa è asimmetrica, per questo devo controllare $ dp\left[i-1\right]\left[j\right] $ e $ dp\left[i\right]\left[j-1\right] $
\vskip3mm
\sfblue{Dimostrazione formale}: dobbiamo dimostrare che date due parole $ U \left(u_1,\ldots ,u_i\right) $ e $ V\left(v_1 , \ldots v_j\right) $ e $ X \left(x_1 , \ldots x_k\right) $ allora
\begin{itemize}
	\item Se $ u_i = v_j $  allora
	      \begin{gather*}
		      u_i = v_j = x_k \\
		      X\left(K-1\right) \in \mathcal{LCS}\left(U\left(i-1\right), V\left(j-1\right)\right)
	      \end{gather*}
	\item Se $ u_i \neq v_j $ e $ x_k \neq  u_i $ allora
	      \[
		      X \in \mathcal{LCS}\left(U\left(i-1\right), V \right)
	      \]
	\item Se $ u_i \neq v_j $ e $ x_k \neq  v_j $ allora
	      \[
		      X \in \mathcal{LCS}\left(U, V\left(j-1\right) \right)
	      \]
\end{itemize}

\begin{minipage}[t]{0.48\textwidth}
	\begin{center}
		\begin{tikzpicture}[scale=0.7]
			\draw (0,0)grid(8,1);
			\draw [fill=mutedgreen!50](7, 0)rectangle ++ (1,1);

			\draw (0,-3)grid(7,-2);
			\draw [fill=mutedred!50](6, -3)rectangle ++ (1,1);

			\begin{scope}[shift={(0.5,0.5)}]
				\node at (-1, 0) {$ U $};

				\node (1) at (0,0)  {a};
				\node (2) at (1,0)  {u};
				\node (3) at (2,0)  {t};
				\node (4) at (3,0)  {s};
				\node (5) at (4,0)  {s};
				\node (6) at (5,0)  {g};
				\node (7) at (6,0)  {n};
				\node (17) at (7,0)  {k};
				\node [anchor = south] at (7,0.5)  {$ i $};

				\node at (-1, -3) {$ V $};

				\node (8)  at (0,-3)  {w};
				\node (9)  at (1,-3)  {a};
				\node (10) at (2,-3)  {t};
				\node (11) at (3,-3)  {f};
				\node (12) at (4,-3)  {x};
				\node (13) at (5,-3)  {m};
				\node (14) at (6,-3)  {g};
				\node [anchor = south] at (6,-2.5)  {$ j $};
				% \node (15) at (7,-3)  {o};
				% \node (16) at (8,-3)  {i};

			\end{scope}

			\node (lcs)[circle] at (2,-1) {lcs};

			\draw (lcs)edge(1.south) edge (3.south) edge(6.south);
			\draw (lcs)edge(9.north) edge (10.north) edge(14.north);

		\end{tikzpicture}
	\end{center}
\end{minipage}
%
\begin{minipage}[t]{0.48\textwidth}
	\begin{center}
		\begin{tikzpicture}[scale=0.7]

			\draw (0,0)grid(6,1);
			\draw [fill=mutedblue!50](5, 0)rectangle(6,1);

			\draw (0,-3)grid(7,-2);
			\draw [fill=mutedblue!50](6, -3)rectangle(7,-2);

			\begin{scope}[shift={(0.5,0.5)}]
				\node at (-1, 0) {$ U $};

				\node (1) at (0,0)  {a};
				\node (2) at (1,0)  {u};
				\node (3) at (2,0)  {t};
				\node (4) at (3,0)  {s};
				\node (5) at (4,0)  {s};
				\node (6) at (5,0)  {g};
				\node [anchor = south] at (5,0.5)  {$ i $};

				\node at (-1, -3) {$ V $};

				\node (8)  at (0,-3)  {w};
				\node (9)  at (1,-3)  {a};
				\node (10) at (2,-3)  {t};
				\node (11) at (3,-3)  {f};
				\node (12) at (4,-3)  {x};
				\node (13) at (5,-3)  {m};
				\node (14) at (6,-3)  {g};
				\node [anchor = south] at (6,-2.5)  {$ j $};
				% \node (15) at (7,-3)  {o};
				% \node (16) at (8,-3)  {i};

			\end{scope}

			\node (lcs)[circle] at (2,-1) {lcs};

			\draw (lcs)edge(1.south) edge (3.south) edge(6.south);
			\draw (lcs)edge(9.north) edge (10.north) edge(14.north);

		\end{tikzpicture}
	\end{center}
\end{minipage}


\subsection{Occorrenza k approssimata}
Data una stringa $ t $ e una $ p $, diciamo che la distanza $ k $ di $ p $ da $ t $ è il numero \underline{minimo} di \textit{inserimenti, eliminazioni e scambi} che dobbiamo fare in $ t $ per far si che $ t == p $.
\[
	t = \text{ "scempio" }, \quad p = \text{ esempio } \rightarrow k = 2
\]
ad esempio, scambiando la "s" e "c" di \textit{scempio} in "e" ed "s" rispettivamente
\vskip3mm
Il problma sta nel trovare in un testo $ t $, la distanza minima di un pattern $ p $ da una sua qualsiasi sottostringa.
\vskip3mm
Ciò equivale a trovare quanti inserimenti, rimozioni e scambi devo fare \underline{nel testo} per far si che il pattern diventi una sua sottostringa
\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Inizializza matrice che ha $ p $ in verticale e $ t $ in orizzontale
	\item In $ dp\left[i\right]\left[j\right] $ si salva \textit{il minor valore di k per far si che $ p\left[0, i\right] $ sia sottostringa di $ t\left[0, j\right] $ che finisca in $ j $}
	\item Se $ p\left[i\right] == t\left[j\right] $ allora non serviranno altre mosse per riportare la soluzione di $ dp\left[i-1\right]\left[j-1\right] $ alla soluzione corrente
	\item Se $ p\left[i\right] \neq  t\left[j\right] $  allora posso fare 3 cose:
\end{itemize}

\begin{center}
	% \includegraphics{images/K approx.pdf }
	\begin{tikzpicture}[scale=0.6]

		\begin{scope}
			\draw [fill=mutedred!50](1,4)rectangle(4,3);
			\draw [fill=mutedgreen!50](0,0)rectangle(1,3);

			\draw (0,0)grid(7,4);

			\draw [thick, mutedblue](0,0)rectangle(1,3);
			\draw [thick, mutedblue](1,4)rectangle(3,3);

			\begin{scope}[shift={(0.5,0.5)}]
				\node at (0,2){b};
				\node at (0,1){a};
				\node at (0,0){b};

				\node at (1,3){a};
				\node at (2,3){b};
				\node at (3,3){a};
				\node at (4,3){b};
				\node at (5,3){a};
				\node at (6,3){g};

				\node at (3,0){?};
				\node at (2,0){$ \rightarrow $};

				% \node at[3,0] {Fai coincidere bab con ab e poi elimina a};
				\node at (3,-1) {+1};
				\node [align = center] at (3,-2) {Fai coincidere bab con ab\\ e poi elimina a};
			\end{scope}
		\end{scope}

		\begin{scope}[shift={(8,0)}]
			\draw [fill=mutedred!50](1,4)rectangle(4,3);
			\draw [fill=mutedgreen!50](0,0)rectangle(1,3);

			\draw (0,0)grid(7,4);

			\draw [thick, mutedblue](0,1)rectangle(1,3);
			\draw [thick, mutedblue](1,4)rectangle(4,3);

			\begin{scope}[shift={(0.5,0.5)}]
				\node at (0,2){b};
				\node at (0,1){a};
				\node at (0,0){b};

				\node at (1,3){a};
				\node at (2,3){b};
				\node at (3,3){a};
				\node at (4,3){b};
				\node at (5,3){a};
				\node at (6,3){g};

				\node at (3,0){?};
				\node at (3,1){$ \downarrow $};

				\node at (3,-1) {+1};
				\node [align = center] at (3,-2) {Fai coincidere ba con aba\\ e poi aggiungi b};
			\end{scope}
		\end{scope}

		\begin{scope}[shift={(16,0)}]
			\draw [fill=mutedred!50](1,4)rectangle(4,3);
			\draw [fill=mutedgreen!50](0,0)rectangle(1,3);

			\draw (0,0)grid(7,4);

			\draw [thick, mutedblue](0,1)rectangle(1,3);
			\draw [thick, mutedblue](1,4)rectangle(3,3);

			\begin{scope}[shift={(0.5,0.5)}]
				\node at (0,2){b};
				\node at (0,1){a};
				\node at (0,0){b};

				\node at (1,3){a};
				\node at (2,3){b};
				\node at (3,3){a};
				\node at (4,3){b};
				\node at (5,3){a};
				\node at (6,3){g};

				\node at (3,0){?};
				\node at (2,1){$ \searrow $};

				\node at (3,-1) {+1};
				\node [align = center] at (3,-2) {Fai coincidere ba con ab\\ e poi cambia a in b};
			\end{scope}
		\end{scope}

	\end{tikzpicture}
\end{center}

La soluzione migliore è data dal minimo valore nell'ultima riga della tabella
\vskip3mm
Nota che la prima riga e la prima colonna vanno riempite rispettivamente con $ \left[0,\ldots , 0\right] $ e $ \left[1,2,\ldots , n-1, n\right] $. Questo ha senso in quanto:
\begin{itemize}
	\item Per far si che il pattern vuoto sia sottostringa di $ t $ non serve alsona mossa ($ \left[0,\ldots ,0\right] $)
	\item Per far sic che un pattern di lunghezza $ k $ sia sottostringa del testo vuoto è necessario aggiungere i $ k $ caratteri del pattern ($ \left[1,2,\ldots , n-1, n\right] $)
\end{itemize}
\subsection{Prodotto di catena di matrici}
Si vuole fare il prodotto matriciale tra $ \left[A_1, A_2,  \ldots, A_{n-1}, A_n \right] $. Il prodotto matriciale gode di proprietà associativa. Si trovi la parentizzazione che riduce al minimo il numero di moltiplicazioni scalari totali da compiere
\vskip3mm
Ad esempio, avendo $ \left[A, B, C, D\right] $, posso parentizzare come segue:
\[
	\left[\left(A \cdot B\right) \cdot \left(C \cdot D\right)\right], \quad \left[A \cdot \left(B \cdot C \right) \cdot D\right], \quad \left[A \cdot \left(B \cdot \left(C  \cdot D\right)\right)\right]
\]
e cosi via. Questo funziona in quanto per moltiplicare delle matrici bisogna assicurarsi che queste siano compatibili. Il numero di colonne della prima deve essere uguale al numero di righe della seconda. Ad esempio, indicando con $ \left[\text{righe}, \text{colonne}\right] $ una matrice, una serie che può essere moltiplicata è la seguente:
\[
	\left[4,5\right] \cdot \left[5, 2\right] \cdot \left[2, 10\right]  \cdot \left[10, 7\right] \rightarrow \left[4,5,2,10,7\right]
\]
\vskip3mm
Nota che la dimensione di ogni matrice può essere salvata in un vettore $ c $ in cui $ c_i $ contiene il numero di colonne della matrice $ i $, che corrisponde al numero di righe della matrice $ i+1 $. Quindi il numero di moltiplicazioni necessarie per eseguire $ A_i \times A_j $ sarà:
\[
	c_i \cdot (\cdot c_{i-1} \cdot c_j)
\]
\begin{itemize}
	\item $ c_i $: numero di moltiplicazioni per calcolare una cella
	\item $ (\cdot c_{i-1} \cdot c_j) $: dimensione della matrice risultante
\end{itemize}
\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Creo matrice \verb|dp| come seguen:
	      \begin{center}
		      \begin{tabular}{|c|c|c|c|c|c|c|}
			      \hline
			        & 1 & 2 & 3 & 4 & 5 & 6 \\
			      \hline
			      1 & 0 &   &   &   &   &   \\
			      \hline
			      2 & - & 0 &   &   &   &   \\
			      \hline
			      3 & - & - & 0 &   &   &   \\
			      \hline
			      4 & - & - & - & 0 &   &   \\
			      \hline
			      5 & - & - & - & - & 0 &   \\
			      \hline
			      6 & - & - & - & - & - & 0 \\
			      \hline
		      \end{tabular}
	      \end{center}
	\item In \verb|dp[i][j]| salvo il minor numero di moltiplicazioni necessarie per moltiplicare le matrici fra \verb|i|  e \verb|j|
	\item Costruisco matrice scorrento in diagonale a partire dalla diagonale più vicina alla diagonale principale. Il numero minore è dato dal numero minore date due parentizzazioni, ad esempio se ho
	      \[
		      \left[A_3,A_4,A_5, A_6\right]
	      \]
	      dovro tentare con
	      \[
		      \left[\left(A_3\right) \cdot  \left(A_4, A_5, A_6\right)\right], \quad \left[\left(A_3, A_4\right) \cdot  \left(A_5, A_6\right)\right], \quad \left[\left(A_3, A_4, A_5\right) \cdot  \left(A_6\right)\right]
	      \]
	\item Il risultato finale si trova in \verb|dp[1][n]|, dove \verb|n| è il numero di matrici
	\item Per ricostruire la parentizzazione, posso salvarmi in una tabella \verb|last[i][j]| l'indice a cui ho "spezzato la parentizzazione". Poi posso ricostruirla ricorsivamente come segue:
\end{itemize}

\begin{algoritmo}{Find minimum parenthesization}
	\begin{algorithm}[H]
		\caption{Print optimal parenthesization}
		\SetKwFunction{FPrintPar}{printPar}
		\Fn{\FPrintPar{$\text{int}\ last[][],\ \text{int}\ i,\ \text{int}\ j$}}{
		\If{$i == j$}{
		\Print "A["; \Print $i$; \Print "]"\;
		}
		\Else{
			\Print "("\;
			\FPrintPar{$last,\ i,\ last[i][j]$}\;
			\Print "."\;
			\FPrintPar{$last,\ last[i][j]+1,\ j$}\;
			\Print ")"\;
		}
		}
	\end{algorithm}
\end{algoritmo}
\subsection{Intervalli pesati}\label{intervalli pesati}
Vengono dati $ n $ intervalli aperti $ \left[a_1, b_1\right[, \left[a_2, b_2\right[ , \ldots  \left[a_n, b_n\right[ $. Ogni intervalli ha un valore $ w_i $. Trovare il valore massimo che si può ottenere selezionando intervalli \underline{non sovrapposti}.

\vskip3mm\sfblue{Soluzione}\vskip3mm
\begin{itemize}
	\item Ordina intervalli per \underline{tempo di fine}
	\item Definisco la funzione \verb|pred(i)|, che ritorna il \textit{predecessore} di un intervallo, ossia il primo intervallo che ha tempo di fine minore del tempo di inizio di $ i $
	\item Creo vettore \verb|dp| che salva in \verb|i| \underline{il valore massimo ottenibile con gli intervalli fino ad {\ttfamily i}} compreso
	\item Itero su intervalli. Per ciascun intervallo \verb|i| posso:
	      \begin{itemize}
		      \item Selezionarlo: in questo il valore massimo ottenibile è dato da {\ttfamily dp[pred(i)] + $ \text{w}_{\text{i}} $} a
		      \item \underline{Non} selezionarlo: in questo caso il valore massimo è uguale al precedente {\ttfamily dp[i-1]}
	      \end{itemize}
\end{itemize}
Complessità: $ O\left(n \log n\right) $

\section{Esercizi dp}

\begin{esercizio}{Sottosequenza massima (Kadane's problem) \href{https://leetcode.com/problems/maximum-subarray}{(link)} }
	Dato in input un vettore {\ttfamily v}, contenente interi (anche negativi), si trovi la \footnote{Una sottosequenza è un insieme di elementi adiacenti all'interno del vettore}{sottosequenza} che abbia somma degli elementi massima. Si ritorni quest'ultima
	\vskip3mm
	\vskip3mm
	\underline{Input}
	\vskip3mm
	La dimensione $ n $ del vettore e sulla nuova riga gli elementi del vettore separati da uno spazio
	\vskip3mm
	\underline{Output}
	\vskip3mm
	La somma degli elementi della sottosequenza con somma massima
	\begin{center}
		\begin{tabularx}{\textwidth}{llX}
			\toprule
			Input & Output & Discussione \\
			\midrule
			\makecell{5                  \\ 1 2 3 4 5} & 15 & La sottosequenza è data dall'intero vettore \\
			\makecell{8                  \\ -2 -3 4 -1 -2 1 5 -3} & 7 & La sottosequenza è data dall'intervallo $ \left[2, 6\right] $ \\
			\makecell{4                  \\ -2 -3 -1 -11 } & 0 & Si assuma che la sottosequenza nulla abbia somma 0  \\
			\bottomrule
		\end{tabularx}
	\end{center}
	Complessità ottimale: $ O\left(v.size\right) $
\end{esercizio}
\vskip3mm

Un approccio naif sarebbe quello di generare tutte le sottosequenze possibili e confrontarne la somma, stampando quella massima. Questo approccio tuttavia sarebbe davvero inefficiente, tuttavia è molto semplice da implementare:
\begin{lstlisting}[language = java, frame = none]
    public static int subsequenceIneff(int v[]) {

    int max = 0;

    for (int i = 0; i < v.length; i++) {

      int currSum = 0;
      for (int j = i; j >= 0; j--) {
        currSum += v[j];
        if (currSum > max)
          max = currSum;
      }

    }

    return max;

  }
\end{lstlisting}
\[
	\text{ Complessità: } O\left(n^2 \right)
\]

Un approccio più efficiente può essere implementato tramite programmazione dinamica. L'idea è la seguente:
\begin{itemize}
	\item Salvo la sottosequenza con somma maggiore che finisce in posizione i-esima
	\item Calcolo la sottosequenza con somma maggiore che finisce in pos $ i+1 $ utilizzando la sottosequenza con somma maggiore che finisce in pos $ i $. Chiamiamo questo vettore \verb|dp|
\end{itemize}
Immaginiamo di salvarci i risultati intermedi in un vettore: questo vettore avrà dimensione $ n $ e conterrà in posizione $ i $ il sottovettore di somma massima che finisce in posizione $ i $. Notiamo innanzitutto che calcolare \verb|dp[0]| è scontato:
\begin{itemize}
	\item Se \verb|v[0] > 0| allora il sottovettore è costituito da un singolo elemento, ovvero \verb|v[0]|
	\item Se \verb|v[0] <= 0| allora il sottovettore è il sottovettore nullo, il quale ha sempre somma 0
\end{itemize}
Per calcolare invece \verb|dp[i]|, ragiono nel seguente modo:
\begin{itemize}
	\item Se \verb|dp[i-1] + v[i] > 0| allora \verb|dp[i] = dp[i-1] + v[i]| (mi conviene prendere la miglior sottosequenza che termina nella posizione prima e sommarci \verb|v[i]|, anche se questo è negativo)
	\item Se \verb|dp[i-1] + v[i] <=0| allora \verb|dp[i] = 0| (conviene "ripartire a formare il vettore", dato che concatenando la subsequence con somma maggiore che termina in $ i-1 $ aggiungerei solo una quantità negativa)
\end{itemize}
\begin{esercizio}{Cuttinig rod}
	Dato un cilindro di lunghezza {\ttfamily n} e un vettore {\ttfamily v} di dimensione {\ttfamily n}, che in {\ttfamily v[i]} contenga il prezzo di un cilindro lungo {\ttfamily i+1}, si stampi il prezzo massimo che posso ottenere tagliando il cilindro in quante parti voglio
	\vskip3mm
	\vskip3mm
	\underline{Input}
	\vskip3mm
	La dimensione $ n $(la lunghezza del cilindro) e sulla nuova riga gli $ n $ interi positivi che costituiscono gli elementi di v(ossia i prezzi di ogni taglio di cilindro)
	\vskip3mm
	\underline{Output}
	\vskip3mm
	Il prezzo massimo che posso ottenere suddividendo il cilindro
	\renewcommand{\cellalign}{l}
	\tikzexternaldisable
	\begin{center}
		\begin{tabularx}{\textwidth}{llX}
			\toprule
			Input & Output & Discussione \\
			\midrule
			\makecell{5                  \\ 1 2 3 4 5} & 5 & Posso tagliare il cilindro in molti modi per ottenere il valore 5:
			\vskip3mm
			{\begin{center}
					 \begin{tikzpicture}[scale = 0.5]
						\draw (0,0)rectangle++(5,1);
						\foreach \x in {0,1,2,3,4,5}{
								\draw [dashed](0,0)++(\x,0)--(\x,1);
							}

						\draw (6,0)rectangle++(5,1);
						\foreach \x in {0,1,3,5}{
								\draw [dotted](6,0)++(\x,0)--++(0,1);
							}
						\draw [dashed](6,0)++(2,0)--++(0,1);
						\draw [dashed](6,0)++(4,0)--++(0,1);




						\draw (0,-2)rectangle++(5,1);
						\foreach \x in {0,1,2,4,5}{
								\draw [dotted](0,-2)++(\x,0)--++(0,1);
							}
						\draw [dashed](0,-2)++(3,0)--++(0,1);

						\draw (6,-2)rectangle++(5,1);
						\foreach \x in {0,1,2,5}{
								\draw [dotted](6,-2)++(\x,0)--++(0,1);
							}
						\draw [dashed](6,-2)++(3,0)--++(0,1);
						\draw [dashed](6,-2)++(4,0)--++(0,1);





						\draw (0,-4)rectangle++(5,1);
						\foreach \x in {0,1,2,3,5}{
								\draw [dotted](0,-4)++(\x,0)--++(0,1);
							}

						\draw [dashed](0,-4)++(4,0)--++(0,1);
						\draw (6,-4)rectangle++(5,1);
						\foreach \x in {0,1}{
								\draw [dotted](6,-4)++(\x,0)--++(0,1);
							}
						\draw [dashed](6,-4)++(4,0)--++(0,1);
						\draw [dashed](6,-4)++(3,0)--++(0,1);
						\draw [dashed](6,-4)++(2,0)--++(0,1);

					\end{tikzpicture}
				 \end{center}
			}
			\\
			\midrule
			\makecell{7                  \\ 1 4 10 8 5 10 13} & 21 & In questo caso ciò che conviene fare è spezzare il cilindro in 2 pezzi di lunghezza 3 e 1 di lunghezza 1:
			{
			\begin{center}
				\begin{tikzpicture}[scale = 0.5]
					\draw (0,0)rectangle++(7,1);
					\foreach \x in {0,1,2,4,5,7}{
							\draw [dotted](0,0)++(\x,0)--(\x,1);
						}
					\draw [dashed](3,0)--++(0,1);
					\draw [dashed](6,0)--++(0,1);

					\node (a)[anchor = north] at(1.5, -0.5)  {10};
					\node (b)[anchor = north] at(4.5, -0.5)  {10};
					\node (c)[anchor = north] at(6.5, -0.5)  {1};
					\draw (a.north)--++(0,0.5);
					\draw (b.north)--++(0,0.5);
					\draw (c.north)--++(0,0.5);

					\node (d)at(3.5, -3)  {21};
					\draw (d)-|(a);
					\draw (d)-|(b);
					\draw (d)-|(c);
				\end{tikzpicture}
			\end{center}
			}
			\\
			\bottomrule
		\end{tabularx}
	\end{center}
	\tikzexternalenable

	Complessità ottimale: $ O\left(n \cdot v.size\left(\right)\right) $
\end{esercizio}\label{cuttingrod}

L'idea di base per risolvere il problema è la seguente:
\begin{itemize}
	\item Creo un vettore \verb|dp| all'interno del quale salvo \underline{nella $ i $-\textit{esima} cella il valore massimo che posso ottenere suddividendo un cilindro di lunghezza $ i+1 $}
	\item Costruisco il vettore \verb|dp| partendo dal caso base: \verb|dp[0] = prezzi [0]|, in quanto ho un solo modo di suddividere un cilindro lungo 1
	\item Contanto sul fatto che il vettore \verb|dp| contenga il \underline{il prezzo maggiore che posso ottenere suddividendo il cilindro in un dato modo}, calcolo \verb|dp[i+1]| sfruttando i dati contenuti nelle celle precedenti del vettore \verb|dp|.In particolare, supponendo di dover calcolare la posizione $ i $ del vettore \verb|dp|, devo:
	      \begin{itemize}
		      \item Calcolare il prezzo che otterrei mettendo in posizione $ i $ un pezzo di ogni lunghezza, da 1 a $ i $
		      \item Confrontare i prezzi ottenuti
		      \item \verb|dp[i]| è il valore massimo fra questi prezzi
	      \end{itemize}
\end{itemize}
Vediamo un esempio grafico. Supponiamo di avere in input il vettore \verb|prezzi|, con valori:
\begin{center}
	1 4 10 8 5 10 13
\end{center}
Ripercorriamo gli step appena descritti.

\begin{itemize}
	\item Creo un vettore \verb|dp| all'interno del quale salvo \underline{nella $ i $-\textit{esima} cella il valore massimo che posso ottenere suddividendo un cilindro di lunghezza $ i+1 $}
	\item Costruisco il vettore \verb|dp| partendo dal caso base: \verb|dp[0] = prezzi [0]|, in quanto ho un solo modo di suddividere un cilindro lungo 1. Quindi nel nostro caso:

	      \begin{center}
		      \begin{tikzpicture}[yscale = 0.5, xscale = 0.8]
			      \draw (0,-2)rectangle++(7,1);
			      \foreach \x in {0,1,2,3,4,5,6,7}{
					      \draw [dotted](0,-2)++(\x,0)--++(0,1);
				      }
			      \node  at (0.5,-1.5)  {1};
			      \node  at (1.5,-1.5)  {4};
			      \node  at (2.5,-1.5)  {10};
			      \node  at (3.5,-1.5)  {8};
			      \node  at (4.5,-1.5)  {5};
			      \node  at (5.5,-1.5)  {10};
			      \node  at (6.5,-1.5)  {13};

			      \node  [anchor = west] at (7,-1.5)  {\ttfamily prezzi};


			      \draw (0,0)rectangle++(7,1);
			      \foreach \x in {0,1,2,3,4,5,6,7}{
					      \draw [dotted](0,0)++(\x,0)--(\x,1);
				      }
			      \node  at (0.5,0.5)  {1};
			      \node  [anchor = west] at (7,0.5)  {\ttfamily dp};

		      \end{tikzpicture}
	      \end{center}

	      Chiaramente, un cilindro id lunghezza 1 non può essere suddiviso, quindi l'unico prezzo possibile è il prezzo del cilindro lungo 1, ossia 1 nel nostro caso


	\item Contanto sul fatto che il vettore \verb|dp| contenga il \underline{il prezzo maggiore che posso ottenere suddividendo il cilindro in un dato modo}, calcolo \verb|dp[i+1]| sfruttando i dati contenuti nelle celle precedenti del vettore \verb|dp|.In particolare, supponendo di dover calcolare la posizione $ i $ del vettore \verb|dp|, devo:
	      \begin{itemize}
		      \item Calcolare il prezzo che otterrei mettendo in posizione $ i $ un pezzo di ogni lunghezza, da 1 a $ i $
		      \item Confrontare i prezzi ottenuti
		      \item \verb|dp[i]| è il valore massimo fra questi prezzi
	      \end{itemize}
	      Iniziamo quindi calcolando \verb|v[1]|. So di avere già calcolato il prezzo migliore per suddividere un cilindro di lunghezza $ 1 $. Quindi per arrivare ad avere un cilindro di lunghezza 2 ho due alternative:

	      \begin{center}
		      \begin{tikzpicture}[yscale = 0.5, xscale = 1.3]


			      \draw (0,2)rectangle++(2,2);
			      \draw (0,3)--(2,3);

			      \node ()[anchor = west]at (2,3.5) {Aggiungo pezzo lungo 1};
			      \node ()[anchor = west]at (2,2.5) {Aggiungo pezzo lungo 2};

			      \draw [pattern = north east lines](1,3)rectangle(2,4);
			      \draw [pattern = north east lines](0,2)rectangle(2,3);

			      \node () at (0.5,3.5)  {\ttfamily dp[0]};
			      \node () at (1.5,3.5)  {\contour{white}{1}};

			      \node () at (1, 2.5)  {\contour{white}{4}};

		      \end{tikzpicture}
	      \end{center}
	      Ora devo decidere se mi convenga prendere un solo cilindro da 2 oppure suddividerlo in due pezzi da 1. Mi basta però vedere quale delle opzioni ha prezzo maggiore. In questo caso conviene prendere un pezzo da 2 con costo 4. Dp diventa:

	      \begin{center}
		      \begin{tikzpicture}[yscale = 0.5, xscale = 0.8]
			      \draw (0,0)rectangle++(7,1);
			      \foreach \x in {0,1,2,3,4,5,6,7}{
					      \draw [dotted](0,0)++(\x,0)--(\x,1);
				      }


			      \node  at (0.5,0.5)  {1};
			      \node  at (1.5,0.5)  {4};
			      \node  [anchor = west] at (7,0.5)  {\ttfamily dp};

			      \draw (0,-2)rectangle++(7,1);
			      \foreach \x in {0,1,2,3,4,5,6,7}{
					      \draw [dotted](0,-2)++(\x,0)--++(0,1);
				      }
			      \node  at (0.5,-1.5)  {1};
			      \node  at (1.5,-1.5)  {4};
			      \node  at (2.5,-1.5)  {10};
			      \node  at (3.5,-1.5)  {8};
			      \node  at (4.5,-1.5)  {5};
			      \node  at (5.5,-1.5)  {10};
			      \node  at (6.5,-1.5)  {13};

			      \node  [anchor = west] at (7,-1.5)  {\ttfamily prezzi};

		      \end{tikzpicture}
	      \end{center}

	      Ripetiamo il passaggio per $ i=3 $
\end{itemize}

\newcommand{\dpvector}{
	\def\rows{1}
	\def\columns{7}
	\def\shiftx{0}
	\def\shifty{-2}


	\foreach \x in {0,1,...,\columns}{
			\draw [dotted](0 + \shiftx,0 + \shifty)++(\x,0)--++(0,\rows);
		}

	\draw (\shiftx, \shifty)rectangle++(\columns, \rows);

	\node ()[anchor = west]at(7,-1.5) {\ttfamily dp};
}

\begin{minipage}[t]{0.48\textwidth}
	\begin{tikzpicture}[yscale = 0.5, xscale = 1.3]


		\def\rows{3}
		\def\columns{3}
		\newcommand{\shiftx}{0}
		\newcommand{\shifty}{0}


		\foreach \x in {0,1,...,\columns}{
				\draw [dotted](0 + \shiftx,0 + \shifty)++(\x,0)--++(0,\rows);
			}

		\foreach \x in {0,1,...,\rows}{
				\draw (0 + \shiftx,0 + \shifty)++(0,\x)--++(\columns,0);
			}

		\draw (\shiftx, \shifty)rectangle++(\columns, \rows);


		\foreach \x in {\rows,...,1}{
				\draw [pattern = north east lines](\shiftx + \columns - \x,\shifty + \rows - \x)rectangle++(\x, );
			}


		\node ()at (2.5, 2.5)  {\contour{white}{1}};
		\node ()at (2, 1.5)  {\contour{white}{4}};
		\node ()at (1.5, 0.5)  {\contour{white}{10}};

		\node ()at(1.5,2.5)  {\ttfamily dp[1]};
		\node ()at(0.5,1.5)  {\ttfamily dp[0]};




	\end{tikzpicture}
	\vskip3mm
	\begin{tikzpicture}[yscale = 0.5, xscale = 0.8]

		\dpvector

		\node ()at(0.5,-1.5) {1};
		\node ()at(1.5,-1.5) {4};
		\node ()at(2.5,-1.5) {\textcolor{gray}{10}};
	\end{tikzpicture}
\end{minipage}
%
\begin{minipage}[t]{0.48\textwidth}

	\begin{tikzpicture}[yscale = 0.5, xscale = 1.3]
		\def\rows{4}
		\def\columns{4}
		\newcommand{\shiftx}{0}
		\newcommand{\shifty}{0}


		\foreach \x in {0,1,...,\columns}{
				\draw [dotted](0 + \shiftx,0 + \shifty)++(\x,0)--++(0,\rows);
			}

		\foreach \x in {0,1,...,\rows}{
				\draw (0 + \shiftx,0 + \shifty)++(0,\x)--++(\columns,0);
			}

		\draw (\shiftx, \shifty)rectangle++(\columns, \rows);


		\foreach \x in {\rows,...,1}{
				\draw [pattern = north east lines](\shiftx + \columns - \x,\shifty + \rows - \x)rectangle++(\x, );
			}

		\node ()at (3.5, 3.5)  {\contour{white}{1}};
		\node ()at (3, 2.5)  {\contour{white}{4}};
		\node ()at (2.5, 1.5)  {\contour{white}{10}};
		\node ()at (2, 0.5)  {\contour{white}{8}};

		\node ()at(2.5,3.5)  {\ttfamily dp[2]};
		\node ()at(1.5,2.5)  {\ttfamily dp[1]};
		\node ()at(0.5,1.5)  {\ttfamily dp[0]};
	\end{tikzpicture}
	\vskip3mm
	\begin{tikzpicture}[yscale = 0.5, xscale = 0.8]

		\dpvector

		\node ()at(0.5,-1.5) {1};
		\node ()at(1.5,-1.5) {4};
		\node ()at(2.5,-1.5) {10};
		\node ()at(3.5,-1.5) {\textcolor{gray}{11}};
	\end{tikzpicture}
\end{minipage}


\vskip20mm


%
\begin{minipage}[t]{0.48\textwidth}
	\begin{tikzpicture}[yscale = 0.5, xscale = 1.3]
		\def\rows{5}
		\def\columns{5}
		\newcommand{\shiftx}{0}
		\newcommand{\shifty}{0}


		\foreach \x in {0,1,...,\columns}{
				\draw [dotted](0 + \shiftx,0 + \shifty)++(\x,0)--++(0,\rows);
			}

		\foreach \x in {0,1,...,\rows}{
				\draw (0 + \shiftx,0 + \shifty)++(0,\x)--++(\columns,0);
			}

		\draw (\shiftx, \shifty)rectangle++(\columns, \rows);


		\foreach \x in {\rows,...,1}{
				\draw [pattern = north east lines](\shiftx + \columns - \x,\shifty + \rows - \x)rectangle++(\x, );
			}

		\node ()at (4.5, 4.5)  {\contour{white}{1}};
		\node ()at (4, 3.5)  {\contour{white}{4}};
		\node ()at (3.5, 2.5)  {\contour{white}{10}};
		\node ()at (3, 1.5)  {\contour{white}{8}};
		\node ()at (2.5, 0.5)  {\contour{white}{5}};

		\node ()at(3.5,4.5)  {\ttfamily dp[3]};
		\node ()at(2.5,3.5)  {\ttfamily dp[2]};
		\node ()at(1.5,2.5)  {\ttfamily dp[1]};
		\node ()at(0.5,1.5)  {\ttfamily dp[0]};
	\end{tikzpicture}
	\vskip3mm
	\begin{tikzpicture}[yscale = 0.5, xscale = 0.8]

		\dpvector

		\node ()at(0.5,-1.5) {1};
		\node ()at(1.5,-1.5) {4};
		\node ()at(2.5,-1.5) {10};
		\node ()at(3.5,-1.5) {11};
		\node ()at(4.5,-1.5) {\textcolor{gray}{14}};
	\end{tikzpicture}
\end{minipage}
%
\begin{minipage}[t]{0.48\textwidth}
	\begin{tikzpicture}[yscale = 0.5, xscale = 1.3]
		\def\rows{6}
		\def\columns{6}
		\newcommand{\shiftx}{0}
		\newcommand{\shifty}{0}


		\foreach \x in {0,1,...,\columns}{
				\draw [dotted](0 + \shiftx,0 + \shifty)++(\x,0)--++(0,\rows);
			}

		\foreach \x in {0,1,...,\rows}{
				\draw (0 + \shiftx,0 + \shifty)++(0,\x)--++(\columns,0);
			}

		\draw (\shiftx, \shifty)rectangle++(\columns, \rows);


		\foreach \x in {\rows,...,1}{
				\draw [pattern = north east lines](\shiftx + \columns - \x,\shifty + \rows - \x)rectangle++(\x, );
			}

		\node ()at (5.5, 5.5)  {\contour{white}{1}};
		\node ()at (5, 4.5)  {\contour{white}{4}};
		\node ()at (4.5, 3.5)  {\contour{white}{10}};
		\node ()at (4, 2.5)  {\contour{white}{8}};
		\node ()at (3.5, 1.5)  {\contour{white}{5}};
		\node ()at (3, 0.5)  {\contour{white}{10}};

		\node ()at(4.5,5.5)  {\ttfamily dp[4]};
		\node ()at(3.5,4.5)  {\ttfamily dp[3]};
		\node ()at(2.5,3.5)  {\ttfamily dp[2]};
		\node ()at(1.5,2.5)  {\ttfamily dp[1]};
		\node ()at(0.5,1.5)  {\ttfamily dp[0]};
	\end{tikzpicture}
	\vskip3mm
	\begin{tikzpicture}[yscale = 0.5, xscale = 0.8]

		\dpvector

		\node ()at(0.5,-1.5) {1};
		\node ()at(1.5,-1.5) {4};
		\node ()at(2.5,-1.5) {10};
		\node ()at(3.5,-1.5) {11};
		\node ()at(4.5,-1.5) {14};
		\node ()at(5.5,-1.5) {\textcolor{gray}{20}};
	\end{tikzpicture}

\end{minipage}

\vskip15mm

\begin{tikzpicture}[yscale = 0.5, xscale = 1.3]
	\def\rows{7}
	\def\columns{7}
	\newcommand{\shiftx}{0}
	\newcommand{\shifty}{0}


	\foreach \x in {0,1,...,\columns}{
			\draw [dotted](0 + \shiftx,0 + \shifty)++(\x,0)--++(0,\rows);
		}

	\foreach \x in {0,1,...,\rows}{
			\draw (0 + \shiftx,0 + \shifty)++(0,\x)--++(\columns,0);
		}

	\draw (\shiftx, \shifty)rectangle++(\columns, \rows);


	\foreach \x in {\rows,...,1}{
			\draw [pattern = north east lines](\shiftx + \columns - \x,\shifty + \rows - \x)rectangle++(\x, );
		}

	\node ()at (6.5, 6.5)  {\contour{white}{1}};
	\node ()at (6, 5.5)  {\contour{white}{1}};
	\node ()at (5.5, 4.5)  {\contour{white}{4}};
	\node ()at (5, 3.5)  {\contour{white}{10}};
	\node ()at (4.5, 2.5)  {\contour{white}{8}};
	\node ()at (4, 1.5)  {\contour{white}{5}};
	\node ()at (3.5, 0.5)  {\contour{white}{10}};

	\node ()at(5.5,6.5)  {\ttfamily dp[5]};
	\node ()at(4.5,5.5)  {\ttfamily dp[4]};
	\node ()at(3.5,4.5)  {\ttfamily dp[3]};
	\node ()at(2.5,3.5)  {\ttfamily dp[2]};
	\node ()at(1.5,2.5)  {\ttfamily dp[1]};
	\node ()at(0.5,1.5)  {\ttfamily dp[0]};
\end{tikzpicture}
\vskip3mm
\begin{tikzpicture}[yscale = 0.5, xscale = 1.3]

	\dpvector

	\node ()at(0.5,-1.5) {1};
	\node ()at(1.5,-1.5) {4};
	\node ()at(2.5,-1.5) {10};
	\node ()at(3.5,-1.5) {11};
	\node ()at(4.5,-1.5) {14};
	\node ()at(5.5,-1.5) {20};
	\node ()at(6.5,-1.5) {\textcolor{gray}{21}};
\end{tikzpicture}


\begin{esercizio}{Somma e media \href{https://training.olinfo.it/\#/task/array/statement}{(link)}}
	Dati in input un numero $ N $, e successivamente $ N $ interi, calcolare la media aritmetica e la somma di questi ultimi
	\vskip3mm
	\underline{Input:}
	\vskip3mm Sulla prima riga l'intero $ N $, sulla seconda riga $ N $ interi separati da uno spazio
	\vskip3mm
	\underline{Output:}
	\vskip3mm Due interi: rispettivamente la somma degli $ N $ numeri e la loro media aritmetica
	\renewcommand{\cellalign}{l}
	\vskip3mm
	\begin{tabularx}{\textwidth}{llX}
		\toprule
		Input & Output & Discussione \\
		\midrule
		\makecell{1                  \\ 12} & 12 12 & Somma e media coincidono e hanno valore 12\\[12pt]
		\makecell{7                  \\ 1 2 34 -56 33 23 89} & 126 18 & Somma e media coincidono e hanno valore 12\\
		\bottomrule
	\end{tabularx}
	\vskip3mm
	Complessità ottimale: $ O\left(N\right) $
\end{esercizio}

\begin{esercizio}{Majority element \href{https://leetcode.com/problems/majority-element/submissions/}{(link)}}
	Dato un array \textit{nums} di dimentione $ n $, ritornare il \textit{majority element}. Il \textit{majority element} è l'elemento che appare \underline{di più} di $ \frac{n}{2} $ volte. Si può assumere che l'elemento esista sempre nell'array
	\vskip3mm
	\underline{Input:}
	\vskip3mm Sulla prima riga l'intero $ n $, sulla seconda riga $ n $, ossia gli elementi di \textit{nums}
	\vskip3mm
	\underline{Output:}
	\vskip3mm Un intero, il majority element
	\vskip3mm
	\renewcommand{\cellalign}{l}
	\begin{tabularx}{\textwidth}{llX}
		\toprule
		Input & Output & Discussione \\
		\midrule
		\makecell{3                  \\ 3 2 3} & 3 & 3 appare più di 3/2 = 1 volta \\[12pt]
		\makecell{7                  \\ 2 2 1 1 1 2 2} & 2 & 2 appare più di 7/2 = 3 volte\\
		\bottomrule
	\end{tabularx}
	\vskip3mm
	Complessità ottimale: $ O\left(n\right) $
\end{esercizio}

\begin{esercizio}{Longest Common Subsequence \href{https://leetcode.com/problems/longest-common-subsequence/}{(link)}}
	Date in input due stringhe \textit{S1} ed \textit{S2}, si ritorni la lunghezza della \textit{longhest common subsequence}, ossia della \footnote{Con \underline{sottoseuquenza} si intende la una stringa che si può ottenere da un'altra eliminando determinati caratteri: \textit{bedbreakfast} è una sottosequenza di \textit{bedandbreakfast}. A differenza di ciò che accade in un \underline{sottovettore}, i caratteri \underline{non} devono essere necessariamente contigui: \textit{bedbreakfast} è sottosequenza ma non sottovettore; \textit{breakfast} è sottosequenza e sottovettore}{sottosequenza} più lunga comunque ad esntrambe le stringhe.
	\vskip3mm
	\underline{Input:}
	\vskip3mm Due stringhe, una per riga, composte da caratteri maiuscoli compresi fra $ A $ e $ Z $
	\vskip3mm
	\underline{Output:}
	\vskip3mm Un intero, la lunghezza della più lunga sottosequenza comune ad entrambe le stringhe
	\vskip3mm
	\renewcommand{\cellalign}{l}
	\begin{tabularx}{\textwidth}{llX}
		\toprule
		Input & Output & Discussione \\
		\midrule
		\makecell{AGGTAB             \\GXTXAYB} & 4 & La sottosequenza comune con lunghezza maggiore è \textit{"GTAB"}, ed ha lunghezza pari a 4  \\[12pt]
		\makecell{AABBCCD            \\  AABBD} & 5 & La sottosequenza comune con lunghezza maggiore è \textit{"AABBD", ed ha lunghezza pari a 5}\\
		\bottomrule
	\end{tabularx}
	\vskip3mm
	Complessità ottimale: $ O\left(s_1.lenght \cdot s_2.lenght\right) $
\end{esercizio}
Per risolvere questo problema dobbiamo utilizzare una matrice di supporto, che salverà i valori intermedi e ci permetterà di utilizzare la programmazione dinamica. Prendiamo come esempio il le stringhe \textit{"AGGTAB"} e \textit{"GXTXAYB"}. La matrice di supporto deve avere la seguente forma:
\begin{center}
	\begin{tabular}{cccccccccl}
		                          &                        & G                      & X                      & T                      & X                      & A                      & Y                      & B                      & s1, j \\ \cline{2-9}
		\multicolumn{1}{c|}{}     & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{0} &       \\ \cline{2-9}
		\multicolumn{1}{c|}{A}    & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  &       \\ \cline{2-9}
		\multicolumn{1}{c|}{G}    & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  &       \\ \cline{2-9}
		\multicolumn{1}{c|}{G}    & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  &       \\ \cline{2-9}
		\multicolumn{1}{c|}{T}    & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  &       \\ \cline{2-9}
		\multicolumn{1}{c|}{A}    & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  &       \\ \cline{2-9}
		\multicolumn{1}{c|}{B}    & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  &       \\ \cline{2-9}
		\multicolumn{1}{l}{s2, i} & \multicolumn{1}{l}{}   & \multicolumn{1}{l}{}   & \multicolumn{1}{l}{}   & \multicolumn{1}{l}{}   & \multicolumn{1}{l}{}   & \multicolumn{1}{l}{}   & \multicolumn{1}{l}{}   & \multicolumn{1}{l}{}   &
	\end{tabular}
\end{center}

Quindi la struttura della matrice è la seguente:
\begin{itemize}
	\item Un orentamento rappresenta una stringa, l'altro l'altra (nota che le stringhe non sono salvate nella matrice, sono riportate in figura solo per rendere il procedimento più chiaro)
	\item La prima colonna e la prima riga sono riempite di zeri. Questo serve perché ci permette di evitare di incappare in indici negativi quando eseguiremo l'algoritmo
	\item Siano \verb|s1| e \verb|s2| le stringhe, nella cella di indice $ \left(i,j\right) $, salveremo \underline{la lunghezza della longest common subsequence per {\ttfamily s1.substring(0,i)} e {\ttfamily s2.substring(0,j)}}
\end{itemize}
\vskip3mm
\begin{minipage}[c]{0.68\textwidth}
	\begin{center}
		\begin{tabular}{cccccccccl}
			                          &                        & G                      & X                      & T                      & X                      & A                      & Y                          & B                      & s1, j \\ \cline{2-9}
			\multicolumn{1}{c|}{}     & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{0}     & \multicolumn{1}{c|}{0} &       \\ \cline{2-9}
			\multicolumn{1}{c|}{A}    & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}      & \multicolumn{1}{c|}{}  &       \\ \cline{2-9}
			\multicolumn{1}{c|}{G}    & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{(1,6)} & \multicolumn{1}{c|}{}  &       \\ \cline{2-9}
			\multicolumn{1}{c|}{G}    & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}      & \multicolumn{1}{c|}{}  &       \\ \cline{2-9}
			\multicolumn{1}{c|}{T}    & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}      & \multicolumn{1}{c|}{}  &       \\ \cline{2-9}
			\multicolumn{1}{c|}{A}    & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}      & \multicolumn{1}{c|}{}  &       \\ \cline{2-9}
			\multicolumn{1}{c|}{B}    & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}      & \multicolumn{1}{c|}{}  &       \\ \cline{2-9}
			\multicolumn{1}{l}{s2, i} & \multicolumn{1}{l}{}   & \multicolumn{1}{l}{}   & \multicolumn{1}{l}{}   & \multicolumn{1}{l}{}   & \multicolumn{1}{l}{}   & \multicolumn{1}{l}{}   & \multicolumn{1}{l}{}       & \multicolumn{1}{l}{}   &
		\end{tabular}
	\end{center}
\end{minipage}
%
\begin{minipage}[c]{0.30\textwidth}
	Ad esempio, nella cella evidenziata, con indice $ \left(1,6\right) $, va salvata la lunghezza della LCS delle stringhe "GXTXAY" e "AG"
\end{minipage}
\vskip3mm
Detto questo, possiamo riempire la tabella secondo i seguenti criteri:
\begin{itemize}
	\item Se {\ttfamily s1[i-1] == s2[j-1]} ciò significa che la soluzione ottimale per quel sottoproblema è data dalla soluzione ottimale per il sottoproblema con le medesime stringhe senza però questultimo carattere. La soluzione di questo problema si trova nella cella $ \left(i-2, j-2\right) $
	\item Se {\ttfamily s1[i-1] != s2[j-1]} allora non ho modo di migliorare la lunghezza della LCS aggiungendo un elemento alle sottostringhe dei problemi precedenti. La soluzione ottimale è quindi da calcolare confrontando le soluzioni ottimali precedenti, in particolare sia {\ttfamily dp} la matrice:
	      \begin{center}
		      \ttfamily dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])
	      \end{center}
	      Volendo ad esempio calcolare il problema per le sottostringhe "GXT" e "AGGTA" posso partire dalle soluzioni dei sottoproblemi per le stringhe "GX", "AGGTA" e "GXT", "AGGT". Mi basta prendere la maggiore di queste due.
	      \vskip3mm
	      Nota anche che non mi serve controllare la soluzione del sottoproblema "GX", "AGGT" in quanto colonne e righe sono tutte ordinate in maniera crescente, quindi è impossibile che la cella $ \left(i-1, j-1\right) $ abbia un valore maggiore della cella $ \left(i, j-1\right) $ o $ \left(i-1, j\right) $
\end{itemize}

\begin{esercizio}{Minimum coin \href{https://leetcode.com/problems/coin-change/description/}{(link)}}
	Vengono dati in input un array contenente un array {\ttfamily coins} (il quale rappresenta monete di diverso taglio) e un numero intero {\ttfamily ammount} (il quale rappresenta il quantitativo totale di monete). Calcolare il numero minimo di monete che si possono utilizzare per arrivare alla somma {\ttfamily ammount} . Si assuma di avere un numero infinito di monete per ogni taglio.
	\vskip3mm
	\underline{Input:}
	\vskip3mm Due righe. Sulla prima gli interi {\ttfamily ammount}  e {\ttfamily n}  (la dimensione di {\ttfamily coins} ), mentre sulla seconda gli elementi di {\ttfamily coins}  separati da uno spazio. Nota che gli elementi di {\ttfamily coins} non vengono necessariamente dati in ordine crescente
	\vskip3mm
	\underline{Output:}
	\vskip3mm Un intero, il numero minimo necessario di monete per arrivare ad {\ttfamily ammount}. Se la combinazione non fosse presente ritornare -1
	\vskip3mm
	\renewcommand{\cellalign}{l}
	\begin{tabularx}{\textwidth}{llX}
		\toprule
		Input & Output & Discussione \\
		\midrule
		\makecell{11 3               \\ 1 2 5} & 3 & Per ottenere la somma 11 posso utilizzare 2 monete da 5 e 1 da 1 \\[12pt]
		\makecell{4 1                \\  3} & -1 & Non è possibile ottenere una somma di 4 con sole monete da 3\\
		\bottomrule
	\end{tabularx}
	\vskip3mm
	Complessità ottimale: $ O\left(coins.size \cdot amount\right) $
\end{esercizio}
Approccio intuitivo (sbagliato): cerco di riempire la somma con monete quanto più grandi possibile. Ad esempio con questo input, tuttavia, non funziona: somma: 20, monete: 15 13 7 1
\vskip3mm
L'approccio corretto è molto simile al problema \textit{\hyperref[cuttingrod]{cutting rod}}. Di fatto è come se dovessimo "riempire" un cilindro lungo {\ttfamily ammount} con pezzi di dimensioni contenute in {\ttfamily coins}.
\vskip3mm
Procediamo così:
\begin{itemize}
	\item Creo vettore \verb|dp| di dimensione \verb|ammount|, all'interno del quale salvo nella cella $ i $ il numero minore di monete per creare una somma pari ad $ i $
	\item \verb|dp[0]=0|, ossia ho modo di creare una somma pari a zero con zero monete
	\item Per calcolare la cella i-esima del vettore \verb|dp|, devo ragionare nel seuguente modo:
	      \begin{itemize}
		      \item Per ogni moneta che abbbia valore inferiore a $ i $, calcoliamo il minor numero di monete che possiamo usare utilizzando il vettore \verb|dp|, in analogia con il problema \textit{\hyperref[cuttingrod]{cutting rod}}. Supponiamo di avere \verb|amount=5, coins=[1, 2, 3, 4]|
		            \begin{center}

			            \begin{tikzpicture}[yscale = 0.5, xscale = 1.3]
				            \def\rows{1}
				            \def\columns{6}
				            \newcommand{\shiftx}{0}
				            \newcommand{\shifty}{0}


				            \foreach \x in {0,1,...,\columns}{
						            \draw [dotted](0 + \shiftx,0 + \shifty)++(\x,0)--++(0,\rows);
					            }

				            \foreach \x in {0,1,...,\rows}{
						            \draw (0 + \shiftx,0 + \shifty)++(0,\x)--++(\columns,0);
					            }

				            \draw (\shiftx, \shifty)rectangle++(\columns, \rows);

				            %\draw [-latex](5 - 0.5, 1)to[out=90, in=90](4 - 0.5, 1);
				            \node at (1 - 0.5, \shifty + 0.5) {0};
				            \node at (2 - 0.5, \shifty + 0.5) {1};
				            \node at (3 - 0.5, \shifty + 0.5) {1};
				            \node at (4 - 0.5, \shifty + 0.5) {1};
				            \node at (5 - 0.5, \shifty + 0.5) {1};
				            \node at (6 - 0.5, \shifty + 0.5) {?};

				            \draw (\columns + 1, 1.5)rectangle(\columns + 2, 5.5);

				            \foreach \x in {0,1,...,2}{
						            \draw [dotted](\columns + 1, 2.5 + \x)--++(1,0);
					            }

				            \node (a)at(\columns + 1.5, 2) {1};
				            \node (b)at(\columns + 1.5, 3) {2};
				            \node (c)at(\columns + 1.5, 4) {3};
				            \node (d)at(\columns + 1.5, 5) {4};
				            \node  at(\columns + 1.5, 6.5) {Monete da:};

				            \draw [-latex](\columns + 1, 5)to[out = 180, in=90](1.5, 1);
				            \draw [-latex](\columns + 1, 4)to[out = 180, in=90](2.5, 1);
				            \draw [-latex](\columns + 1, 3)to[out = 180, in=90](3.5, 1);
				            \draw [-latex](\columns + 1, 2)to[out = 180, in=90](4.5, 1);

				            \node (1)at(\columns + 3.5, 2) {1 + dp[4] = 2};
				            \node (2)at(\columns + 3.5, 3) {1 + dp[3] = 2};
				            \node (3)at(\columns + 3.5, 4) {1 + dp[2] = 2};
				            \node (4)at(\columns + 3.5, 5) {1 + dp[1] = 2};
				            \node  at(\columns + 3.5, 6.5) {Best sol};

				            \draw (a)--(1);
				            \draw (b)--(2);
				            \draw (c)--(3);
				            \draw (d)--(4);
			            \end{tikzpicture}

			            La miglior souzione per una somma pari a 5 è quindi 2. Possiamo usare 2 monete in modi diversi ((3,2), (4,1)) per ottenere la somma 5
		            \end{center}
	      \end{itemize}
	\item Mettendo in ordine il concetto intuitivo dobbiamo creare \verb|dp[i]| mettendo nel seguente modo:
	      \begin{itemize}
		      \item Per ogni elemento di \verb|coins| che sia minore di \verb|i| calcolo il numero minimo di monete che è necessario per arrivare ad una somma di \verb|i| utilizzando \verb|dp|. Supponendo di dover includere una moneta di valore \verb|value|, allora il minor numero di monete per arrivare a \verb|i| è dato da
		            \begin{center}
			            \verb|dp[i-value] + 1|
		            \end{center}
		      \item Il valore minimo di monete per arrivare alla somma \verb|i| è il valore minimo fra tutti quelli calcolari al punto precedente
		      \item Occhio ai casi nei quali non è possibile ottenere una somma specifica tramite le monete a disposizione. In questi casi metteremo il valore -1 nel vettore \verb|dp|
	      \end{itemize}
\end{itemize}
\begin{esercizio}{Unique paths \href{https://leetcode.com/problems/unique-paths/description/}{(link)} }
	Un robot si muove su di una griglia {\ttfamily n x m}. Il robot inizialmente è posizionato sulla cella $ \left[0\right]\left[0\right] $ e deve arrivare alla cella $ \left[m-1\right]\left[n-1\right] $. Il robot può muoversi solamente verso il basso e verso destra. Dati due interi {\ttfamily n, m} che indicano la dimensione della griglia, calcolare il numero di percosi possibili
	\vskip3mm
	\vskip3mm
	\underline{Input}
	\vskip3mm
	Gli interi {\ttfamily m} e {\ttfamily n}
	\vskip3mm
	\underline{Output}
	\vskip3mm
	Il numero di percorsi possibili
	\renewcommand{\cellalign}{l}
	\begin{center}
		\begin{tabularx}{\textwidth}{llX}
			\toprule
			Input & Output & Discussione                                                                                        \\
			\midrule
			2 2   & 2      & I percorsi possibili sono $[(R \rightarrow D), (D \rightarrow R)]$                                 \\[12pt]
			3 2   & 3      & I percorsi possibili sono \vskip0mm
			$(R \rightarrow D \rightarrow D)$, $(D \rightarrow D \rightarrow R)$, $\left(D \rightarrow R \rightarrow D\right)]$ \\
			\bottomrule
		\end{tabularx}
	\end{center}
	Complessità ottimale: $ O\left(n \cdot  m\right) $
\end{esercizio}\label{uniquepaths}

L'idea di base è la seguente:
\begin{itemize}
	\item Creo matrice {\ttfamily dp} che salva nella generica cella $ \left[i\right]\left[j\right] $ il numero di percorsi tramite i quali posso arrivare in $ \left[i\right]\left[j\right] $
	\item Inizializzo la prima colonna e la prima riga della matrice a 1: per raggiungere le celle della prima riga e colonna ho un solo modo, ossia rispettivamente spostarmi a destra o spostarmi in basso (non posso tornare indietro)
	\item Per ogni cella che avanza calcolo il valore come la somma della cella a sinistra e della cella a sopra: questo perche per arrivare nella cella $ \left[i\right]\left[j\right] $ posso passare per la cella $ \left[i-1\right]\left[j\right] $ oppure per la cella $ \left[i\right]\left[j-1\right] $. La somma dei modi che ho per arrivare nelle suddette celle è il numero di modi che ho per arrivare nella cella corrente
	\item Una volta generata l'intera tabella, nella ultima cella in basso a destra avro il risultato al problema
\end{itemize}
\begin{gather*}
	\begin{bmatrix}
		1 & 1 & 1 & 1 & 1 & 1 & 1 \\
		1 & 2 & / & / & / & / & / \\
		1 & / & / & / & / & / & / \\
	\end{bmatrix}
	\begin{bmatrix}
		1 & 1 & 1 & 1 & 1 & 1 & 1 \\
		1 & 2 & 3 & / & / & / & / \\
		1 & / & / & / & / & / & / \\
	\end{bmatrix}
	\begin{bmatrix}
		1 & 1 & 1 & 1 & 1 & 1 & 1 \\
		1 & 2 & 3 & 4 & / & / & / \\
		1 & / & / & / & / & / & / \\
	\end{bmatrix}
	\begin{bmatrix}
		1 & 1 & 1 & 1 & 1 & 1 & 1 \\
		1 & 2 & 3 & 4 & 5 & / & / \\
		1 & / & / & / & / & / & / \\
	\end{bmatrix}
	\\
	\begin{bmatrix}
		1 & 1 & 1 & 1 & 1 & 1 & 1 \\
		1 & 2 & 3 & 4 & 5 & 6 & / \\
		1 & / & / & / & / & / & / \\
	\end{bmatrix}
	\begin{bmatrix}
		1 & 1 & 1 & 1 & 1 & 1 & 1 \\
		1 & 2 & 3 & 4 & 5 & 6 & 7 \\
		1 & / & / & / & / & / & / \\
	\end{bmatrix}
	\begin{bmatrix}
		1 & 1 & 1 & 1 & 1 & 1 & 1 \\
		1 & 2 & / & / & / & / & / \\
		1 & 3 & / & / & / & / & / \\
	\end{bmatrix}
	\begin{bmatrix}
		1 & 1 & 1 & 1 & 1 & 1 & 1 \\
		1 & 2 & 3 & / & / & / & / \\
		1 & 3 & 6 & / & / & / & / \\
	\end{bmatrix}
	\\
	\begin{bmatrix}
		1 & 1 & 1 & 1  & 1 & 1 & 1 \\
		1 & 2 & 3 & 4  & / & / & / \\
		1 & 3 & 6 & 10 & / & / & / \\
	\end{bmatrix}
	\begin{bmatrix}
		1 & 1 & 1 & 1  & 1  & 1 & 1 \\
		1 & 2 & 3 & 4  & 5  & / & / \\
		1 & 3 & 6 & 10 & 15 & / & / \\
	\end{bmatrix}
	\\
	\begin{bmatrix}
		1 & 1 & 1 & 1  & 1  & 1  & 1 \\
		1 & 2 & 3 & 4  & 5  & 6  & / \\
		1 & 3 & 6 & 10 & 15 & 21 & / \\
	\end{bmatrix}
	\begin{bmatrix}
		1 & 1 & 1 & 1  & 1  & 1  & 1  \\
		1 & 2 & 3 & 4  & 5  & 6  & 7  \\
		1 & 3 & 6 & 10 & 15 & 21 & 28 \\
	\end{bmatrix}
\end{gather*}


\begin{esercizio}{Unique paths II \href{https://leetcode.com/problems/unique-paths/description/}{(link)} }
	Un robot si muove su di una griglia {\ttfamily n x m}. Il robot inizialmente è posizionato sulla cella $ \left[0\right]\left[0\right] $ e deve arrivare alla cella $ \left[m-1\right]\left[n-1\right] $. Il robot può muoversi solamente verso il basso e verso destra. Sulla griglia possono essere presenti degli ostacoli attraverso i quali il robot non può passare. Data una matrice {\ttfamily obstacles}, nella quale le celle con valore 1 indicano le celle con ostacoli, trovare il numero di percorsi possibili per arrivare nell'ultima cella in fondo a destra
	\vskip3mm
	\vskip3mm
	\underline{Input}
	\vskip3mm
	Gli interi {\ttfamily m} e {\ttfamily n} e nelle {\ttfamily m} righe successiva gli elementi della matrice {\ttfamily obstacles}
	\vskip3mm
	\underline{Output}
	\vskip3mm
	Il numero di percorsi possibili
	\renewcommand{\cellalign}{l}
	\begin{center}
		\begin{tabularx}{\textwidth}{llX}
			\toprule
			Input & Output & Discussione                                                                     \\
			\midrule
			\makecell{3 3                                                                                    \\ 0 0 0 \\ 0 1 0 \\ 0 0 0}& 2  & I percorsi possibili sono \vskip0mm
			$[(R \rightarrow R \rightarrow D \rightarrow D), (D \rightarrow D \rightarrow R \rightarrow R)]$ \\
			\bottomrule
		\end{tabularx}
	\end{center}
	Complessità ottimale: $ O\left(n \cdot  m\right) $
\end{esercizio}

L'idea è molto simile al problema \hyperref[uniquepaths]{Unique paths}, con l'unica differenza che dobbiamo tenere in considerazione i casi in cui una rotta è preclusa da un ostacolo. Inoltre, anzichè creare una nuova matrice {\ttfamily dp}, possiamo usare direttamente la matrice {\ttfamily obstacles} che ci viene data.
\begin{itemize}
	\item Riempio la prima colonna e riga della matrice {\ttfamily obstacles} con valore 1 fino al primo ostacolo. Dal primo ostacolo in poi avrò solo celle irraggiungibili. Setto le celle irraggiungibili con valore -1, in quanto usando 1 rischierei di confondere le celle irraggiungibili con le celle raggiungibili da 1 solo cammino
	\item Calcolo le celle rimanenti con la stessa logica usata in \hyperref[uniquepaths]{Unique paths}, tenendo conto però che:
	      \begin{itemize}
		      \item Nel caso ci sia un ostacolo nella cella a sinistra o in alto a quella corrente non posso arrivare da quella direzione. Se non rimane nemmeno una rotta possibile posso impostare il valore della della a -1, in quanto non riesco a ragiungerla in nessun modo
		      \item Nel caso ci sia un ostacolo nella cella corrente ({\ttfamily obstacles[i][j] == 1}) cambio il valore e metto -1, onde evitare ambiguità come spiegato precedentemente
	      \end{itemize}
	\item Ancora una volta, nella cella $ \left[m-1,n-1\right] $ ci sarà la soluzione del problema
\end{itemize}

\begin{gather*}
	\begin{bmatrix}
		0 & 0 & 0 \\
		0 & 1 & 0 \\
		0 & 0 & 0 \\
	\end{bmatrix}
	\xrightarrow{\text{riempio prima riga e colonna}}
	\begin{bmatrix}
		1 & 1 & 1 \\
		1 & 1 & 0 \\
		1 & 0 & 0 \\
	\end{bmatrix}
	\xrightarrow{\text{ cambio ostacolo in -1}}
	\begin{bmatrix}
		1 & 1  & 1 \\
		1 & -1 & 0 \\
		1 & 0  & 0 \\
	\end{bmatrix}
	\\
	\begin{bmatrix}
		1 & 1  & 1 \\
		1 & -1 & 1 \\
		1 & 0  & 0 \\
	\end{bmatrix}
	\begin{bmatrix}
		1 & 1  & 1 \\
		1 & -1 & 0 \\
		1 & 1  & 0 \\
	\end{bmatrix}
	\begin{bmatrix}
		1 & 1  & 1 \\
		1 & -1 & 1 \\
		1 & 1  & 2 \\
	\end{bmatrix}
\end{gather*}



\section{Problemi sito oii consigliati}\label{problemi oii}
Di seguito una raccolta di problemi provenienti dal sito degli allenamenti della OII. Sono proposte delle soluzioni in sezione \cref{soluzioni problemi oii}

\begin{center}
	\begin{tabular}{l l l l}
		\toprule
		Problema                                                                                                     & Tecniche               & Difficoltà                                        & Soluzione               \\
		\midrule
		Figonacci {(\texttt{\href{https://training.olinfo.it/task/ois_figonacci}{figonacci}})}                       & dp                     & \ding{72} \ding{73} \ding{73} \ding{73} \ding{73} & \cref{sol figonacci}    \\
		Discesa massima {(\protect{\texttt{\href{https://training.olinfo.it/task/discesa}{discesa}}})}               & dp                     & \ding{72} \ding{73} \ding{73} \ding{73} \ding{73} & \cref{sol discesa}      \\
		Police 3 {(\protect{\texttt{\href{https://training.olinfo.it/task/ois_police3}{\ttfamily police3}}})}        & dp                     & \ding{72} \ding{73} \ding{73} \ding{73} \ding{73} & \cref{sol police3}      \\
		Piano degli studi {(\protect{\texttt{\href{https://training.olinfo.it/task/ois_pianostudi}{pianostudi}}})}   & dp, binary search      & \ding{72} \ding{72} \ding{72} \ding{73} \ding{73} & \cref{sol pianostudi}   \\
		Spiedini di frutta {(\protect{\texttt{\href{https://training.olinfo.it/task/oii_spiedini}{spiedini}}})}      & dp                     & \ding{72} \ding{72} \ding{73} \ding{73} \ding{73} & \cref{sol spiedini}     \\
		K-step ancestor {(\protect{\texttt{\href{https://training.olinfo.it/task/ois_treeancestor}{treeancestor}}})} & dp, graph              & \ding{72} \ding{72} \ding{73} \ding{73} \ding{73} & \cref{sol treeancestor} \\
		Taglialegna {(\protect{\texttt{\href{https://training.olinfo.it/task/oii_taglialegna}{taglialegna}}})}       & dp, amortized analysis & \ding{72} \ding{72} \ding{72} \ding{72} \ding{72} & \cref{sol taglialegna}  \\
		\bottomrule
	\end{tabular}
\end{center}
\newpage

\section{Soluzioni problemi sito OII}\label{soluzioni problemi oii}
Di seguito una raccolta di soluzioni per i problemi proposti in \cref{problemi oii}. Per ogni problema è riportato il link alla pagina del problema e il link alla soluzione proposta in questa dispensa.
\subsection{Figonacci {(\protect\texttt{\href{https://training.olinfo.it/task/ois_figonacci}{figonacci}})}}
\label{sol figonacci}
\begin{center}
	\begin{tabularx}{\textwidth}{X r}
		\toprule
		Problema sito OII  & \url{https://training.olinfo.it/task/ois_figonacci}                       \\
		Soluzione proposta & \ttfamily\href{run:./files/esercizi/figonacci/}{files/esercizi/figonacci} \\
		\bottomrule
	\end{tabularx}
\end{center}
L'idea qui è di "srotolare" la sommatoria, rendendosi conto che
\begin{align*}
	G_n & = \sum_{i=0}^{i=n-2} G_{n-1} - G_i                                                                                                       \\
	    & = \left(G_{n-1} - G_{n-2}\right) + \left(G_{n-1} - G_{n-3}\right) + \ldots + \left(G_{n-1} - G_{1}\right) + \left(G_{n-1} - G_{0}\right) \\
	    & = \left(n-1\right) G_{n-1} - \sum_{i=0}^{i = n-2} G_{i}                                                                                  \\
	    & = \left(n-1\right) G_{n-1} + G_{n-1}-\left(n-2\right)G_{n-2} - G_{n-2}                                                                   \\
	    & = \left(n-1\right) G_{n-1} - \left(n-1\right)f\left(n-2\right) + G_{n-1}                                                                 \\
	    & = \left(n-1\right)  \left(G_{n-1} - G_{n-2}\right) + G_{n-1}
\end{align*}
abbiamo così ottenuto a tutti gli effetti una formula che possiamo applicare direttamente in forma ricorsiva(con \textit{memoization}) o iterativa:
\begin{center}
	\ttfamily
	dp[i] = (i-1)(dp[i-1]*dp[i-2]) + dp[i-1]
\end{center}

\subsection{Discesa massima {(\protect{\texttt{\href{https://training.olinfo.it/task/discesa}{discesa}}})}}
\label{sol discesa}
\begin{center}
	\begin{tabularx}{\textwidth}{X r}
		\toprule
		Problema sito OII  & \url{https://training.olinfo.it/task/discesa}                         \\
		Soluzione proposta & \ttfamily\href{run:./files/esercizi/discesa/}{files/esercizi/discesa} \\
		\bottomrule
	\end{tabularx}
\end{center}
L'idea in questo caso è di creare un albero di discesa in cui in ogni posizione \verb|[i][j]| salviamo \textit{il maggior peso di una discesa che termina nella posizione \texttt{[i][j]}}.
\vskip3mm
Ad esempio, qui sotto è riportato a destra l'albero \verb|dp| per l'albero in input di sinistra
\[
	\begin{array}{c}
		1                       \\
		2 \quad  9              \\
		3 \quad 7\quad 5        \\
		8 \quad4\quad 11\quad 6 \\
	\end{array}
	\quad
	\rightarrow
	\quad
	\begin{array}{c}
		1                            \\
		3 \quad  10                  \\
		6 \quad 17\quad 15           \\
		14 \quad 21\quad 28 \quad 21 \\
	\end{array}
\]
rimane da capire come calcolare i valori nella file $ i $ esima basandosi sui precedenti. In particolare abbiamo 3 casi:
\begin{itemize}
	\item \textit{Primo elemento}: posso arrivare \textit{solo da destra}, quindi:
	      \begin{center}
		      \verb|dp[i][0]=dp[i-1][0] + w[i][0]|
	      \end{center}
	\item \textit{Ultimo elemento}: posso arrivare \textit{solo da sinistra}, quindi
	      \begin{center}
		      \verb|dp[i][size]=dp[i-1][size-1] + w[i][size]|
	      \end{center}
	\item \textit{Elemento in mezzo}: posso arrivare sia da sinistra che da destra, quindi dovro prendere la strada che fra le due ha peso maggiore:
	      \begin{center}
		      \verb|dp[i][j]=w[i][j] + max(dp[i][j], dp[i][j+1])|
	      \end{center}
\end{itemize}
Chiaramente il caso base è quello riguardante il primo elemento, per cui il persorso di peso massimo è dato dal peso dell'elemento stesso.
\vskip3mm
Occorre ragionare un filo meglio sugli indici ma la logica rimane inalterata. Nota bene: \textit{è veramente necessario salvare l'intera matrice dp?}


\subsection{Police 3 {(\protect{\texttt{\href{https://training.olinfo.it/task/ois_police3}{\ttfamily police3}}})}}
\label{sol police3}
\begin{center}
	\begin{tabularx}{\textwidth}{X r}
		\toprule
		Problema sito OII  & \url{https://training.olinfo.it/task/ois_police3}                     \\
		Soluzione proposta & \ttfamily\href{run:./files/esercizi/discesa/}{files/esercizi/police3} \\
		\bottomrule
	\end{tabularx}
\end{center}
L'idea qui è, per quanto banale possa semprare, ad ogni semaforo abbiamo due opzioni: fermarsi o meno. Per questa ragione possiamo salvare informazioni in due vettori \verb|dp|, per ciascuno dei due casi:
\begin{itemize}
	\item \verb|ts[i]|: salva in $ i $ il minor tempo per superare il semaforo $ i $ fermandosi a quest'ultimo
	\item \verb|tr[i]|: salva in $ i $ il minor tempo per superare il semaforo $ i $, scappando
\end{itemize}
possiamo costruire i valori dei due vettori basandoci sui precedenti secondo la seguente logica
\begin{itemize}
	\item Se \textit{mi fermo} al semaforo $ i $-esimo, il tempo ideale sarà dato dall'attesa al semaforo + il tempo migliore ottenuto fermandosi o meno a quello precedente (posso scegliere di fermarmi oppure no, siccome non violo nessun vincolo in ogni caso)
	      \begin{center}
		      \ttfamily
		      ts[i] = T[i] + min(tr[i - 1], ts[i - 1]);
	      \end{center}
	\item Se \textit{non mi fermo} al semaforo $ i $-esimo, il tempo ideale sarà dato dal tempo ideale per arrivare al semaforo $ i-1 $, fermandocisi (in questo caso devo assicurarmi di fermarmi al semaforo precedente per non violare alcun vincolo)
	      \begin{center}
		      \ttfamily
		      tr[i] = ts[i - 1];
	      \end{center}
\end{itemize}
Anche in questo caso, è davvero necessario salvare l'interi vettori in memoria?

\subsection{Piano degli studi {(\protect{\texttt{\href{https://training.olinfo.it/task/ois_pianostudi}{pianostudi}}})}}
\label{sol pianostudi}
\begin{center}
	\begin{tabularx}{\textwidth}{X r}
		\toprule
		Problema sito OII  & \url{https://training.olinfo.it/task/ois_pianostudi}                        \\
		Soluzione proposta & \ttfamily\href{run:./files/esercizi/pianostudi/}{files/esercizi/pianostudi} \\
		\bottomrule
	\end{tabularx}
\end{center}

\subsection{Police 4 {(\protect{\texttt{\href{https://training.olinfo.it/task/ois_police4}{\ttfamily police4}}})}}
\label{sol police4}
\begin{center}
	\begin{tabularx}{\textwidth}{X r}
		\toprule
		Problema sito OII  & \url{https://training.olinfo.it/task/ois_police4}                     \\
		Soluzione proposta & \ttfamily\href{run:./files/esercizi/police4/}{files/esercizi/police4} \\
		\bottomrule
	\end{tabularx}
\end{center}
L'idea in questo caso è di salvare di volta il tempo minimo per arrivare al semaforo \verb|i| avendone saltati al più \verb|j|. Questa informazione può essere mantenuta in una matrice $ n \times r $, dove $ n $ è il numero di \textit{semafori} e $ r $ il numero massimo di semafori che \textit{possono essere saltati}.
\vskip3mm
La $ i $-esima colonna/riga della matrice può essere calcolata usando la precedente. In particolare, supponiamo di voler calcolare il tempo minore per arrivare al semaforo $ i $ saltandone al più $ j $. Allora ho due opzioni:
\begin{itemize}
	\item Arrivo al semaforo $ i-1 $ saltandone al massimo $ j-1 $. In questo caso il tempo ideale è quello ottenuto saltando il semaforo $ i-1 $
	\item Arrivo al semaforo $ i-1 $ saltandone al più $ j $. In questo caso devo controllare se devo aspettare o meno. In caso affermativo devo aggiungere il tempo di attesa alla soluzione
\end{itemize}
La soluzione ottimale è data dalla migliore delle due. Formarlmente dati $ T $ e $ X $, rispettivamente l'intervalli dei semafori e il vettore delle posizioni, posso calcolare \verb|dp| come segue:
\begin{center}
	\begin{lstlisting}[language = cpp, frame = none]
  t1 = dp[i-1][j-1];
  t2 = dp[i-1][j] + (can_pass ? 0 : T-dp[i-1][j] % T);
  dp[i][j] = min(t1, t2) + X[i] - X[i-1];
\end{lstlisting}
\end{center}
\begin{center}
	\ttfamily
\end{center}

\subsection{Spiedini di frutta {(\protect{\texttt{\href{https://training.olinfo.it/task/oii_spiedini}{spiedini}}})}}
\label{sol spiedini}
\begin{center}
	\begin{tabularx}{\textwidth}{X r}
		\toprule
		Problema sito OII  & \url{https://training.olinfo.it/task/oii_spiedini}                      \\
		Soluzione proposta & \ttfamily\href{run:./files/esercizi/spiedini/}{files/esercizi/spiedini} \\
		\bottomrule
	\end{tabularx}
\end{center}
L'idea è che una volta che uno spiedino è stato mangiato fino ad un certo punto da una parte, allora la soluzione ideale è prefissata e consiste nel mangiarlo dalla parte opposta finchè è possibile. La chiave sta tuttavia nel comprendere che non è necessario calcolare tutta la somma da capo ad ogni iterazione, ma possiamo seguire questa logica:
\begin{itemize}
	\item Mangio lo spiedino \textit{da sinistra} fino all'ultima fragola che permette di \textit{non} superare la soglia. Tengo sempre traccia della soglia corrente
	\item Partendo \textit{da destra} mangio lo spiedino fino a quando la soglia lo permette
	\item Tengo traccia del numero di fragole mangiate
	      i
\end{itemize}
Dopodichè, ripeto questi step fino a quanto non raggiungo l'estremità sinistra dello spiedino:
\begin{itemize}
	\item Da sinistra, scorro fino alla fragola precedente, abbassando la soglia
	\item Da destra scorro fino all'ultima fragola che riesco ad includere, aggiornando soglia e quantità di fragole mangiate
\end{itemize}
La soluzione migliore ottenuta in ogni step dell'iterazione precedente è la soluzione ottimale al problema

\subsection{K-step ancestor {(\protect{\texttt{\href{https://training.olinfo.it/task/ois_treeancestor}{treeancestor}}})}}
\label{sol treeancestor}
\begin{center}
	\begin{tabularx}{\textwidth}{X r}
		\toprule
		Problema sito OII  & \url{https://training.olinfo.it/task/ois_treeancestor}                          \\
		Soluzione proposta & \ttfamily\href{run:./files/esercizi/treeancestor/}{files/esercizi/treeancestor} \\
		\bottomrule
	\end{tabularx}
\end{center}
La soluzione sta nell'esplorare l'albero tenendo traccia della profondità corrente e del tragitto che ha portato fino al nodo che stiamo attualmente visitato. Possiamo fare ciò tramite 2 variabili \verb|depth| e \verb|path[n]|
\vskip3mm
Dato che il grado in questo caso è semplicemente un albero, possiamo sfruttare anche una semplice \href{https://en.wikipedia.org/wiki/Depth-first_search}{DFS}, dato che possiamo essere sicuri che il path che ci porta a ciascun nodo è unico.
\vskip3mm
Per ciascun nodo, controlliamo se la depth è maggiore o minore di $ K $. Nel primo caso sfruttiamo l'array contenente il path per assegnare il valore del $ k $-ancestor, nel secondo semplicemente assegnamo -1. Formalmente:
\begin{lstlisting}[language = java, frame = none]
if (depth >= K) {
  ancestor[node] = path[depth - K];
} else {
  ancestor[node] = -1;
}
\end{lstlisting}
nella DFS chiamiamo ricorsivamente la funzione con un valore di \verb|depth| incrementato di 1 ogni volta

\subsection{Taglialegna {(\protect{\texttt{\href{https://training.olinfo.it/task/oii_taglialegna}{taglialegna}}})}}
\label{sol taglialegna}
\begin{center}
	\begin{tabularx}{\textwidth}{X r}
		\toprule
		Problema sito OII  & \url{https://training.olinfo.it/task/oii_taglialegna}                         \\
		Soluzione proposta & \ttfamily\href{run:./files/esercizi/taglialegna/}{files/esercizi/taglialegna} \\
		\bottomrule
	\end{tabularx}
\end{center}
Il problema è piuttosto avanzato, per questo è necessario fare delle osservazioni preliminari che torneranno utili dopo.
\begin{enumerate}
	\item In una soluzione ottima ho 3 opzioni:
	      \begin{enumerate}
		      \item L'ultimo albero a destra viene tagliato e fatto cadere a \textit{sinistra}
		      \item L'ultimo albero a destra viene tagliato e fatto cadere a \textit{destra}
		      \item L'ultimo albero a destra \textit{non} viene tagliato ma fatto cadere a \textit{destra} per "effetto domino"
	      \end{enumerate}
	      L'idea importante è che in una soluzione ottima l'ultimo albero a destra, se cade a sinistra è perchè è stato tagliato e fatto cadere a sinistra. Per quanto sia ovvio è molto importante per capire gli step successivi
	\item Gli unici punti in cui si può interrompere l'effetto domino sono i punti in cui vi sono alberi di altezza 1
	\item Per quanto detto al punto precedente, possiamo vedere il problema come una serie di intervalli che errano fatti cadere in una delle due direzioni. Agli estremi di questi intervalli ci sono alberi di altezza 1
	\item Quando avviene un effetto domino, non tutti gli alberi partecipano nella catena della caduta. In particolare un albero può essere abbattuto da un albero che non è quello precedente nella catena. Chiameremo questo albero \verb|ff|(first-falling) di \verb|i|. Possiamo quindi considerare l'effetto domino solo per gli alberi abbattitori, nel modo seguente:
	      \[
		      i \rightarrow \operatorname{ff}\left[i\right] \rightarrow \operatorname{ff}\left[\operatorname{ff}\left[i\right]\right] \rightarrow \ldots
	      \]
\end{enumerate}
Detto questo, individuiamo il sotto-problema di programmazione dinamica e il caso base. In particolare sappiamo che:
\begin{itemize}
	\item Il sotto-problema consiste nel calcolare il \textit{il numero minore di tagli} per abbattere gli alberi da 0 a i
	\item Il caso base è quanto $ n=1 $, ossia quando ho un solo albero. In questo caso la soluzione è fare un unico taglio
\end{itemize}
\hypertarget{taglialegna solution steps}{}Rimane ora capire come utilizzare le soluzioni ottime da 0 a $ i-1 $ per calcolare la $ i $-esima soluzione ideale. Possiamo ragionare così per calcolare la soluzione ottimale $ i $-esima:
\begin{itemize}
	\item Se l'albero viene \textit{tagliato a sinistra}, allora simulo l'effetto domino e verifico dove questo si interrompe. Supponendo che la catena abbia fatto cadere $ k $ alberi, allora
	      \begin{center}
		      \ttfamily
		      solution[i] = 1 + solution[i-k-1]
	      \end{center}
	\item Se l'albero viene \textit{tagliato a destra}, allora non rimane che pulire in maniera ottimale gli alberi da 0 a $ i-1 $, quindi:
	      \begin{center}
		      \ttfamily
		      solution[i] = 1 + solution[i-1]
	      \end{center}
	\item Se l'albero viene \textit{fatto cadere a destra}, allora all'interno della \textit{catena dei first-fall} devo capire quale albero è più conveniente tagliare per innescare l'effetto domino. Chiamando questo albero \verb|opt|, allora la soluzione ottimale è data da
	      \begin{center}
		      \ttfamily
		      solution[i] = 1 + solution[opt-1]
	      \end{center}
\end{itemize}
Andiamo ora ad elencare le strutture dati che ci aiuteranno nel calcolo progressivo del vettore \verb|solution|
\begin{itemize}
	\item \verb|lb[i]|: \textit{left-bound}, contiene nella posizione $ i $ l'indice fino al quali gli alberi cadono se l'albero $ i $ viene tagliato a \textit{sinistra}
	\item \verb|rb[i]|:\textit{right-bound}, contiene nella posizione $ i $ l'indice fino al quali gli alberi cadono se l'albero $ i $ viene tagliato a \textit{destra}
	\item \verb|ff[i]|: \textit{first-fall}, come descritto precedentemente, il primo albero alla sinistra di $ i $ che in un effetto a catena colpisce $ i $
\end{itemize}
\hypertarget{taglialegna dp data}{}Come vedremo, possiamo calcolare tutti questi vettori in tempo $ O\left(n\right) $

%int solution[n];

%// In which direction should I cut the last tree in order to obtain i-th
%// optimal solution: 0=left 1=right
%bool dir[n];

%// Saves the optimal spot to to start the domino effect when making the trees
%// fall to the right
%int opt_split[n];

%// Saves the first tree to cut in the i-th optimal solution
%int first_cut[n];

\begin{itemize}
	\item \verb|solution[i]|: il vettore \textit{dp} principale. Salva la soluzione ottimale per il range $ \left[0,i\right] $
	\item \verb|dir[i]|: il vettore che contiene la direzione in cui va tagliato il primo albero per ottenere la soluzione ottimale
	\item \verb|opt_split[i]|: \textit{optimal-split}, salva la posizione ottimale per dare inizio all'effetto domino nella soluzione migliore in cui l'ultimo albero cade a destra
	\item \verb|first_cut[i]|: salva l'indice del primo albero da tagliare nella $ i $-esima sotto soluzione ottimale
\end{itemize}
\hypertarget{taglialegna step 1}{}\sfblue{Parte 1:} calcolo \verb|lb|, \verb|rb|
\vskip3mm
Partiamo dal calcolo dei vettori \verb|lb| e \verb|rb|. L'idea è proprio quella di simulare a tutti gli effetti l'effetto domino. In particolare, pensiamo di avere una serie di intervalli che cadono per effetto domino e un albero che viene fatto cadere a sinistra:

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}
			\node (a)[whitedot, minimum width=1cm] at (0,0) {$ k_n $};
			\node (b)[whitedot, minimum width=1cm] at (2,0) {$k_{n-1}$};
			\node (c)[whitedot, minimum width=1cm] at (4,0) {$k_2$};
			\node (d)[whitedot, minimum width=1cm] at (6,0) {$k_1$};
			\node (e)[whitedot, minimum width=1cm] at (9,0) {$ i $};

			\draw [latex-latex, thick](a)--(b) node [midway, below]{$ n $};
			\draw [latex-latex, dashed](b)--(c) node [midway, below]{$ \ldots  $};
			\draw [latex-latex, thick](c)--(d) node [midway, below]{$ 2 $};
			\draw [latex-latex, thick](d)--(e) node [midway, below]{$ 1 $};

			\draw [-latex][ultra thick](e)--++(0,8);
			% \draw [latex-latex, thick](5,0)--(8,0) node [midway, below]{d};
			\draw [dashed, -latex](e)++(0,8)to[out=180, in = 90](1,0);
			\node[fit=(current bounding box.south west)(current bounding box.north east)] {};
		\end{tikzpicture}
	\end{center}
	\caption{Calcolo left-bound}
	\label{calcolo left bound}
\end{figure}
In questa figura, sappaimo già che gli intervalli da 1 a $ n $ cadono a sinistra per effetto domino, interrompendosi nei punti $ k_2, \ldots , k_n $. \verb|lb[i]| sarà quindi dato da valore più basso fra i \verb|lb| degli intervalli che l'albero abbatte sicuramente, ossia tutti gli intervalli il cui albero più a destra viene abbattuto dall'albero $ i $. In figura, questi sono precisamente gli intervalli $ 1, \ldots , n $. Più formalmente

\begin{algoritmo*}{Calcolo left-bound}
	\begin{algorithm}[H]
		\SetKwFunction{FComputeLeftBound}{compute\_left\_bound}
		\Fn{\Int$\left[\right]$ \FComputeLeftBound{$n, h$}}{
		\Int $ lb  \leftarrow $ \New \Int $[0\ldots n-1]$\;
		% \Int lb $ \leftarrow $ \New~\Int[n]\;
		\For{$i \leftarrow 0$ \KwTo $n-1$}{
		$lb[i] \leftarrow i$\;
		\While{$lb[i] > 0 \land lb[i] > i - h[i] + 1$}{
		$lb[i] \leftarrow lb[\,lb[i] - 1\,]$\;
		}
		}
		\Return{$lb$}\;
		}
	\end{algorithm}
\end{algoritmo*}
Il calcolo del vettore \verb|rb| è speculare, ma segue la medesima logica.
\vskip3mm
Ora è fondamentale discurete la complessità di questa funzione. Potremmo in un primo momento pensare \textit{erroneamente} che la funzione abbia complessità di $ O\left(n^2 \right) $, dato che il ciclo esterno scorre l'interno vettore e, nel caso peggiore, anche quello interno scorre tutti gli elementi da $ i $ a 0. Tuttavia, il ragionamento è un filo più sottile.
\vskip3mm
Diciamo che un albero viene \textit{saltato da $ i $} se all'interno del ciclo while che calcola \verb|lb[i]| viene utilizzato per aggiornare il valore di \textit{lower-bound}
\[
	lb[i] \leftarrow lb[\underbracket[0.1ex]{lb[i] - 1}_{\text{saltato}}]
\]
Aiutandoci con la figura \ref{calcolo left bound}, possiamo intuire che gli alberi saltati, nel calcolo di \verb|lb[i]|, sono dati da $ k_1, k_2, \ldots k_{n-1} $. La chiave sta nel capire che \underline{ogni albero può essere saltato una volta sola}. Questo avviene in quanto, supponendo che gli alberi $ k_1,\ldots k_{n - 1} $ vengano saltati dall'albero $ i $, allora nelle iterazioni successive questi non possono più essere saltati, in quanto al più verrà saltato prima l'albero $ i $, il quale avrà un \textit{left-bound} minore di $ k_{n-1} $, quindi tutto il range in cui stanno gli alberi $ k_1,\ldots k_{n-1} $ non verrà considerato nella computazione.
\vskip3mm
Quindi, ancora una volta, siccome ogni albero viene saltato una e una sola volta, la riga $ 	lb[i] \leftarrow lb[lb[i] - 1]$ del ciclo while viene eseguita al più $ n $ volte, portando ad una complessità totale di $ O\left(n\right) $
\vskip3mm
\hypertarget{taglialegna step 2}{}\sfblue{Parte 2:} calcolo \verb|ff|
\vskip3mm
Il calcolo di \verb|ff| può implementato in maniera piuttosto semplice con piccolissime modifiche alla funzione che calcola \verb|rb|. Sempre riferendoci a \cref{calcolo left bound}, possiamo notare che il primo albero ad abbattere gli alberi $ k_1,\ldots ,k_{n-1} $ in una catena di abbattitori è $ i $. Per questo motivo ogni volta che calcoliamo \verb|rb[i]| possiamo anche aggiornare il valore per \verb|ff| degli alberi $ k_1,\ldots k_{n-1} $. Formalmente:
\begin{algoritmo*}{Calcolo right-bound e first-fall}
	\begin{algorithm}[H]
		\SetKwFunction{FComputeRightBound}{compute\_rb\_ff}
		\Fn{\Int[] \FComputeRightBound{$n, h$}}{
			\Int $rb \leftarrow$ \New \Int $[0\ldots n-1]$\;
			\Int $ff \leftarrow$ \New \Int $[0\ldots n-1]$\;
			\For{$i \leftarrow n-1$ \Downto $0$}{
				$rb[i] \leftarrow i$\;
				$ff[i] \leftarrow -1$\;
				\While{$ rb[i] < n-1 $ \And $ rb[i] < i + h[i] - 1 $}{
					$ ff[rb[i] + 1] \leftarrow i $\;
					$ rb[i] \leftarrow rb[rb[i] + 1] $\;
				}
			}
			\Return{rb, ff}\;
		}
	\end{algorithm}
\end{algoritmo*}
La complessità rimane sempre $ O\left(n\right) $

\vskip3mm
\hypertarget{taglialegna step 3}{}\sfblue{Parte 3:} calcolo \verb|solution|
\vskip3mm
Innanzitutto, ci appoggeremo alle strutture dati \verb|dp| descritte \hyperlink{taglialegna dp data}{qui}. Per calcolare il vettore \verb|solution|, gli step sono, dal punto di vista logico, quelli descritti \hyperlink{taglialegna solution steps}{qui}. Descriviamo più nel dettaglio le 2 casistiche:
\begin{itemize}
	\item Taglio a sinistra:
	      \begin{lstlisting}[language = cpp, frame = none]
solution[i] = 1 + (lb[i] > 0 ? solution[lb[i] - 1] : 0);
opt_cut[i] = i;
dir[i] = 0;\end{lstlisting}%
	\item Albero cade a destra:
	      \begin{itemize}
		      \item Taglio a destra:
		            \begin{lstlisting}[language = cpp, frame = none]
solution[i] = 1 + (idx2 > 0 ? solution[i - 1] : 0);
\end{lstlisting}
		      \item Albero abbattuto a destra per effetto domino:
		            \begin{lstlisting}[language = cpp, frame = none]
split_index = opt_split[ff[i]]; // Optimal index to cut the tree
solution[i] = 1 + (idx1 > 0 ? solution[split_index - 1] : 0);
\end{lstlisting}
	      \end{itemize}
\end{itemize}
Ora ci rimane solo da aggiornare il vettore \verb|opt_cut|, così da rendere l'intero algoritmo efficiente. Anche qui la programmazione dinamica viene in nostro soccorso. Più in particolare, so che supponendo che la catena di $ k $ first fall che abbattono $ i $ sia composta dagli alberi $ 1,2,\ldots ,k-1,i $. Allora so già che fra i primi $ k-1 $ il migliore è dato da \verb|opt_split[k-1]|, non rimane che testare l'ultimo, ossia il caso in cui $ i $ è abbattuto a destra. Nel caso la soluzione migliore si ottenesse con la prima opzione, allora \verb|opt_split[i]=opt_split[ff[i]]|, altrimenti \verb|opt_split[i] = i|
\vskip3mm
Chiaramente, scorrendo ogni elemento del vettore una sola volta, la funzione ha complessità $ O\left(n\right) $

\begin{algoritmo*}{Calcolo soluzione}
	\begin{algorithm}[H]
		% \caption{Compute optimal cuts for trees (DP)}
		% \label{alg:forest-dp-func}

		% \KwIn{$n$, arrays $lb[1..n]$, $rb[1..n]$, $ff[1..n]$}
		% \KwOut{$solution[1..n]$, $first\_cut[1..n]$, $dir[1..n]$, $opt\_split[1..n]$}
		\SetKwFunction{FComputeSolution}{compute\_solution}
		\Fn{\FComputeSolution{$n, lb, rb, ff$}}{
			\vskip3mm
			$solution[0] \leftarrow 1$\;
			$dir[0] \leftarrow 1$\;
			$opt\_split[0] \leftarrow 0$\;
			$first\_cut[0] \leftarrow 0$\;

			\vskip3mm
			\For{$i \leftarrow 1$ \KwTo $n$}{
				\vskip3mm
				% Case 1: last tree is cut to the left
				\Comment{Case 1: last tree is cut to the left}
				$sol_{1} \leftarrow 1 + $\leIf{$ lb[i] > 0 $}{$solution[lb[i] - 1]$}{$0$}
				$cut_{1} \leftarrow i$\;
				$dir_{1} \leftarrow \KwFalse$\;

				\vskip3mm
				% Case 2: last tree falls to the right
				\Comment{Case 2: last tree falls to the right}
				\If{$ff[i] \neq -1$}{

					\vskip3mm
					% Case 2.1: tree falls for domino effect
					\Comment{Case 2.1: tree falls by domino effect}
					$idx_{1} \leftarrow opt\_split[ff[i]]$\;
					$sol_{21} \leftarrow 1 + $\leIf{$idx_{1} > 0$}{$solution[idx_{1} - 1]$}{$0$}

					\vskip3mm
					% Case 2.2: tree is cut to the right
					\Comment{Case 2.2: tree is cut to the right}
					$idx_{2} \leftarrow i$\;
					$sol_{22} \leftarrow 1 + $\leIf{$idx_{2} > 0$}{$solution[idx_{2} - 1]$}{$0$}

					\vskip3mm
					$opt\_split[i] \leftarrow $\leIf{$sol_{21} < sol_{22}$}{$ idx_{1} $}{$ idx_{2} $}
				}
				\Else{
					$opt\_split[i] \leftarrow i$\;
				}

				\vskip3mm
				$sol_{2} \leftarrow 1 + $\leIf{$opt\_split[i] > 0$}{$solution[opt\_split[i] - 1]$}{$0$}

				$cut_{2} \leftarrow opt\_split[i]$\;
				$dir_{2} \leftarrow \KwTrue$\;

				\vskip3mm
				% Saving better solution
				\If{$sol_{1} < sol_{2}$}{
					$solution[i] \leftarrow sol_{1}$\;
					$first\_cut[i] \leftarrow cut_{1}$\;
					$dir[i] \leftarrow dir_{1}$\;
				}
				\Else{
					$solution[i] \leftarrow sol_{2}$\;
					$first\_cut[i] \leftarrow cut_{2}$\;
					$dir[i] \leftarrow dir_{2}$\;
				}
			}

			\Return{$solution, first\_cut, dir$}\;
		}
	\end{algorithm}
\end{algoritmo*}

\vskip3mm
\hypertarget{taglialegna step 4}{}\sfblue{Parte 4:} ricostruire la soluzione
\vskip3mm
Una volta calcolati i vettori \verb|solution|, \verb|first_cut| e \verb|dir| è piuttosto immediato ricostruire la soluzione "risalendo" al contrario i tagli che sono stati fatti:
\begin{algoritmo}{Ricostruzione soluzione}
	\begin{algorithm}[H]

		\SetKwFunction{FReconstructSolution}{reconstruct\_solution}
		\SetKwFunction{FAbbatti}{abbatti}
		\Fn{\FReconstructSolution{$n, first\_cut, dir$}}{
			$pos \leftarrow n - 1$\;
			\While{$pos \ge 0$}{

				\FAbbatti{$first\_cut[pos], dir[pos]$}\;

				\If{$dir[pos] = \KwFalse$}{
					$pos \leftarrow lb[pos] - 1$\;
				}
				\Else{
					$pos \leftarrow first\_cut[pos] - 1$\;
				}
			}
		}
	\end{algorithm}
\end{algoritmo}
Complessivamente, abbiamo che
\begin{center}
	\begin{tabular}{l l l}
		\toprule
		Step                                   & task                                                 & complessità          \\
		\midrule
		\hyperlink{taglialegna step 1}{Step 1} & calcolo \verb|lb|, \verb|rb|                         & $ O\left(n\right) $  \\
		\hyperlink{taglialegna step 2}{Step 2} & calcolo \verb|ff|                                    & $ O\left(n\right) $  \\
		\hyperlink{taglialegna step 3}{Step 3} & calcolo \verb|solution|, \verb|dir|, \verb|best_cut| & $ O\left(n\right) $  \\
		\hyperlink{taglialegna step 4}{Step 4} & ricostruisco soluzione                               & $  O\left(n\right) $ \\
		\bottomrule
	\end{tabular}
\end{center}
Complessità totale: $ O\left(n\right) $

\end{document}
